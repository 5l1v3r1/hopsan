namespace hopsan::Component {
/*!
\page userCustomComponents Custom Components & Libraries

-# \subpage introduction-component-libraries \n
-# \subpage creating-modifying-component-appearance \n
-# \subpage writing-components \n
-# \subpage component-generator \n
-# \subpage generating-components-mathematica \n
-# \subpage unittest-components \n

\page introduction-component-libraries Introduction to Component Libraries

Hopsan uses pre-compiled components. An external component library can be loaded in the program by clicking on the Load External Library icon, in the bottom of the library widget.

\htmlonly
<table border="0">
<tr>
<td>&nbsp;&nbsp;&nbsp;<img src="../../graphics/loadlibrary_icon.png" border=0>
</td>
<td><b>Load External Library</b></td>
</tr>
</table>
\endhtmlonly
\image latex "../../graphics/loadlibrary_icon.png" "Load External Library"

A Hopsan component library consists of at least three types of files.
-# The compiled component library code as a .\b dll Windows (Dynamic Link Library) file or as a .\b so (Shared Object) file (Linux/Mac).
-# A set of .\b xml files that describes the graphical appearance of each component.
-# A set of .\b svg (Scalable Vector Graphics) files containing component icon graphics.

There needs to be one .xml file for every component in the library but .svg files can be shared if needed. All components should however be compiled into one single .dll/.so file.
A library typically consists of a directory, containing one .dll/.so file and the .xml and .svg files. Subdirectories containing the .xml and .svg files can be used to create sub categories in the library. The directory hierarchy will be shown in the Hopsan GUI Component Library Widget.

If you have access to the component library source code some additional important files should also be mentioned.
-# One \e "libraryName.cc" file. This is the source code file that is compiled into the .dll/.so .
-# One or several \e "componentName.hpp" files containing the component source code.
-# A project file, or a so called Makefile (build script) that is needed for building the code into the .dll/.so.

If you are only a user of the library you can ignore these additional files, component developers should refer to \link writing-components Writing Components in C++ \endlink 

\page creating-modifying-component-appearance Create or Modify Component Appearance

\section component_svg Graphical Icons (.svg)
Icons for the graphical interface are stored in the Scalable Vector Graphics format. A good tool, which is free and open-source, for creating and editing such files is Inkscape. If you want to use bitmaps graphics, .jpg, .png or similar formats, such graphics can be embedded in a .svg file.

<a href="http://inkscape.org/">Inkscape Webpage</a>


\section component_xml Appearance Description Files (.xml)
Information about the component for the graphical interface, such as icon, port positions and component name, is stored in a .xml file. This file contains information about the component that is not part of the actual simulation code. This information can be changed without the need to recompile the actual component code. A typical appearance file looks like this:

\verbatim
<?xml version="1.0" encoding="UTF-8"?>
<hopsanobjectappearance version="0.3">
  <modelobject typename="HydraulicLaminarOrifice" subtypename="Orifice1" displayname="Laminar Orifice">
    <icons>
      <icon type="iso" path="laminarorifice_iso.svg" iconrotation="ON" scale="1.0"/>
      <icon type="user" path="laminarorifice_user.svg" iconrotation="ON" scale="1.0"/>
    </icons>
    <help>
      <text>Help Text</text>
      <picture>helpPicture.svg</picture>
    </help>
    <ports>
      <port name="P1" x="1.0" y="0.5" a="0" visible="true"/>
      <port name="P2" x="0.0" y="0.5" a="180" visible="true"/>
      <port name="Kc" x="0.5" y="0.0" a="270" visible="true">
        <description>The orifice coefficient</description>
      </port>
    </ports>
  </modelobject>
</hopsanobjectappearance>
\endverbatim

The first line contains basic information about the XML code, and should always look the same. A description of the remaining tags follows:

- \b hopsanobjectappearance Main tag for appearance file
  - \b version Should always be 0.3 with this XML layout
- \b modelobject Main tag for the component
  - \b typename Name of the component as registered in the simulation core, see \link writing-components Writing Components \endlink. (Required)
  - \b subtypename Specific version of a typename component, if you have multiple appearance files for the same component code. (Optional)
  - \b displayname Name for the component shown in the graphical interface. (If omitted typename will be used)
- \b icons Contains information about icons. At least one type, user or iso is required.
  - \b type The icon type, \e user or \e iso (ISO 1219)
  - \b path Relative path from the .xml file to the .svg
  - \b iconrotation Tells whether or not the icon rotates when the component is rotated in the workspace
  - \b scale Lets you adjust the scale of the .svg graphics (without modifying the actual .svg file) (default=1.0 if omitted)
- \b help Allows you to specify help information explaining the function of the component. (Optional)
  - \b text The help text. (Optional)
  - \b picture The path to the .svg help picture. (Optional)
- \b ports Defines the positions and orientations for each port (Required for each port)
  - \b name Name of the port as defined in the code
  - \b x X-position fraction of component icon width (0 = left, 1 = right)
  - \b y Y-position fraction of component icon height (0 = top, 1 = bottom)
  - \b a Angle of port, 0 = right, 90 = down, 180 = left, 270 = up, ports shall normally point outwards from the component
  - \b visible Is the port is visible by default, \e true or \e false. A hidden port is never shown. (If omitted defaults to true)
  - \b description A description text (help text) for the port. (Optional)



\page writing-components Writing Components in C++

\section writingcomponents_introduction-writing-components Introduction Writing Custom Components 
The majority of the Hopsan component code is contained within the HopsanCore. When the user is creating a new component only the parts which make the new component unique needs to be specified. All other functionality is inherited from the base implementation in the HopsanCore. The code that is written for the new components must be compiled into the .dll/.so file. This file will contain the runtime executable code for the new components. While simulating, Hopsan will call functions in this file each time step.

The compiled library file can include one or several new components. It must also include two mandatory functions used by the HopsanCore to get information and to register the contents of the library once it is loaded.

If you have not already done so, read the \link introduction-component-libraries \endlink for a description of the library files.

\section writingcomponents_exampleComponentLibrary The Example Component Library
The examples bellow are based on the exampleComponentLibrary that should be included with your version of Hopsan. These examples contains subsets of the original files. Also read the original files for their full content. They also include additional comments. When creating a new component library, use the example files as a getting started template.

\section writingcomponents_prerequisites Prerequisites
  - Qt Creator
  - MinGW32 Compiler (MS Windows) or GNU GCC (Linux)
  - Basic knowledge of C++
  - Basic knowledge of TLM modeling

The exampleComponentLibrary project file is specific for the Qt Creator C++ IDE but technically it is possible to use any IDE (code writing software). Knowledge about TLM is not required for writing arithmetic components. See \link userTransmissionLineElementMethod the Transmission Line Element Method \endlink for more information.

**On Windows**
You can download Qt Creator and the Qt libraries from http://qt-project.org/downloads, for Hopsan 0.6.0 use 4.8.4 MinGW version.
You will also need a special version of MinGW and the gdb debugger, we have put the files and a short guide here https://www.dropbox.com/sh/3ve9b7oqsdnwta2/7XdjHUBkrp

**On Ubuntu**
You can download Qt Creator from http://qt-project.org/downloads
You will aslo need to install "apt-get install qt4-dev-tool" and maybe the libqt4-dev package.


\section writingcomponents_libraryfiles Component Library Project Files

\subsection writingcomponents_file_pro exampleComponentLib.pro
This is the project file for Qt Creator. If you are using a different coding environment, you need to create a similar file for that environment. It is also possible to write a custom make file manually.  

Three modifications is required in this files. First of all the \b INCLUDEPATH must be changed so that it points to the "include" folder in the Hopsan installation. Similarly, the \b LIBS path must point to the "bin" folder in the installation directory. Finally, the relative path to all components source files in the library must be specified under HEADERS.

\code
QT -= core gui
TEMPLATE = lib

TARGET = exampleComponentLib
DESTDIR = $${PWD}/
INCLUDEPATH *= $${PWD}/../../HopsanCore/include/
LIBS *= -L$${PWD}/../../bin

CONFIG(debug, debug|release) {
    LIBS *= -lHopsanCore_d
    DEFINES *= DEBUGCOMPILING
}
CONFIG(release, debug|release) {
    LIBS *= -lHopsanCore
    DEFINES *= RELEASECOMPILING
}

SOURCES += \
    exampleComponentLib.cc

HEADERS += \
    component_code/MyExampleVolume.hpp \
    component_code/MyExampleOrifice.hpp

OTHER_FILES +=
\endcode

\subsection writingcomponents_file_cc exampleComponentLib.cc
This file contains code that is used to register you library components in the Hopsan simulation core. Two modifications are required. 
- First of all, all component code files must be included. (They will be copied into this file during compilation)
- Second, each component needs to be registered in the simulation core by the pComponentFactory->registerCreatorFunction("KeyValue", CreatorFunction) lines.\n
The \e "KeyValue" argument must be a unique typename that identifies you component. The \e CreatorFunction argument is the Creator function in each component.
- Theird, Make sure that you write a unique libName (as a string) in the get_hopsan_info function. Leave the two last lines as they are.

\code
#include "component_code/MyExampleOrifice.hpp"
#include "component_code/MyExampleVolume.hpp"

#include "ComponentEssentials.h"
using namespace hopsan;

extern "C" DLLEXPORT void register_contents(ComponentFactory* pComponentFactory, NodeFactory* pNodeFactory)
{
    pComponentFactory->registerCreatorFunction("MyExampleOrifice", MyExampleOrifice::Creator);
    pComponentFactory->registerCreatorFunction("MyExampleVolume", MyExampleVolume::Creator);
}

extern "C" DLLEXPORT void get_hopsan_info(HopsanExternalLibInfoT *pHopsanExternalLibInfo)
{
    pHopsanExternalLibInfo->libName = (char*)"HopsanExampleComponentLibrary";
    pHopsanExternalLibInfo->hopsanCoreVersion = (char*)HOPSANCOREVERSION;
    pHopsanExternalLibInfo->libCompiledDebugRelease = (char*)DEBUGRELEASECOMPILED;
}
\endcode

\subsection writingcomponents_file_svg_xml XML and SVG files
The XML files contain the appearance description, and the SVG files are the icons, see \link creating-modifying-component-appearance Creating or Modifying Component Appearance \endlink.

\subsection writingcomponents_file_hpp MyExampleOrifice.hpp & MyExampleVolume.hpp
These files contains the source code for the components, see below.


\section writingcomponents_codestructure Component Code Structure
Components are written in header-only C++ files (.hpp). Let's take a look at "MyExampleOrifice.hpp". The file consist of the following parts:

This first line includes the essential functions for the component from the simulation core. It may be necessary to include more files, for example "ComponentUtilities.h" for accessing built-in component utilities in Hopsan, or external header files.
\dontinclude MyExampleOrifice.hpp
\skipline #include

Next the component class is declared. We inherit from a \b ComponentQ as this is a Q-type component.
This could also be \b ComponentC or \b ComponentS for C-type or Signal-type components.
\skipline class MyExampleOrifice

First the \e private part of the component is specified. Here we declare member variables, (variables that should be persistent in the component).
In this case we have a restriction coefficient called \b mKc and two port pointers called \b mpP1 and \b mpP2 ("m" is an abbreviation of "member" and "mp" means "member and pointer").
\skip private:
\until Port

In the \e public part we first define a static creator function, which is used to create instances of the component in the simulation core. Nothing needs to be changed except the name of the class.
\skip static Component *Creator()
\until }

The second member function you need to define is the \e Configure function for the component. This function is run every time a new object of the class is created (added to the model).
The function is used to configure set default values of member variables and to register ports and parameters.
First we give the restrictor coefficient a default value. Then we create the ports used for communication with surrounding components, in this case two hydraulic powerports.
Finally we register the restrictor coefficient as parameter with a name, description and unit. This will make it available to the user in the graphical interface. 
\skip void configure()
\until }

The following functions are available for port creation:
You need to specify a unique (within the component) portname, which node type it should use, and whether a connection to it is Port::REQUIRED or Port::NOTREQUIRED. If the final argument is omitted it will default to REQUIRED.
\code 
Port* addPowerPort(const string portName, const string nodeType, const Port::ReqConnEnumT reqConnect=Port::REQUIRED);
Port* addReadPort(const string portName, const string nodeType, const Port::ReqConnEnumT reqConnect=Port::REQUIRED);
Port* addWritePort(const string portName, const string nodeType, const Port::ReqConnEnumT reqConnect=Port::REQUIRED);
Port* addPowerMultiPort(const string portName, const string nodeType, const Port::ReqConnEnumT reqConnect=Port::REQUIRED);
Port* addReadMultiPort(const string portname, const string nodetype, const Port::ReqConnEnumT reqConnect=Port::REQUIRED);
\endcode

The currently available built-in node types can be found here: \ref Nodes "NodeTypes"\n
New node types can be added through external libraries, but this should be avoided if possible.

For parameter registration the following functions are available. The correct register function will automatically be selected depending on the value type.
The register functions will register the given name, unit and description and connect this information to a pointer pointing at the variable you specify as the \b rValue argument.
\code
void registerParameter(const string name, const string description, const string unit, double &rValue, const ParamDynConstT dynconst=dynamic);
void registerParameter(const string name, const string description, const string unit, int &rValue);
void registerParameter(const string name, const string description, const string unit, string &rValue);
void registerParameter(const string name, const string description, const string unit, bool &rValue);
\endcode

For more useful functions see \ref ComponentAuthorFunctions

The next member function that must be defined is the \e Initialize function.
This function is run once before the first time step in the simulation. As this function is run after connections have been establish you can read or write to/from connected components. 
If needed you can use this information to initialize your component properly. This is also the place to allocate aditional memory if needed. 
In this function you also typically initialize more advanced utilities such as (but not limited to) Delays, Integrators or Transfer-functions. 
In this example case we have nothing that needs to be initialized.
\skip void initialize()
\until }

 
The next function is the most important member function. It contains the model equations that are executed each time step.
We begin with creating local variables from the connected ports, and we end by writing back the new values we have calculated.
This procedure is intended to make the actual equations more readable. The middle part is the actual equations. 
In this case we calculate flow and pressure through the orifice from wave variables and impedance in the neighbouring C-type components.
\skip void simulateOneTimestep()
\until }

The last member function is optional. It is only useful if you want some code to be run after simulation has finished.
This is usually only needed if you want to free memory that you have additionally allocated in the \e initialize function.
\skip void finalize()
\until }

\section writingcomponents_compilation Compilation

When everything is finished, the project must be compiled. It is necessary to use the MinGW32 compiler, because Hopsan is compiled with this compiler. The project must also be compiled in "release" mode.
Compilation goes through two phases, first the .cc file or files are compiled and then they are linked into one .dll or .so file.

If you have written something wrong in your code you may get a compilation error that you need to correct. Usually these error messages are quite descriptive.
You may also get linker errors which are usually a bit more difficult to understand if you are not used to compiling you own code.

If you get something similar to the following error message: \"<tt>cannot find -lHopsanCore</tt>\" you have probably set the LIBS path incorrectly in your project file.\n

If compilation was successful, a .dll or.so file will appear in the directory. It should now be possible to load the library from Hopsan, by pointing out the directory - see \ref introduction-component-libraries "Introduction".

\page component-generator Component Generator Dialog
Hopsan has a built-in component generator dialog, from where new components can be written without deeper knowledge of the Hopsan simulation core interface. It accessed from the "Generate New Component" icon at the bottom of the library widget.

\htmlonly
<table border="0">
<tr>
<td>&nbsp;&nbsp;&nbsp;<img src="../../graphics/generatenewcomponent_icon.png" border=0>
</td>
<td><b>Generate New Component</b></td>
</tr>
</table>
\endhtmlonly

In this dialog it is possible to specify component name (used by simulation core, must not contain spaces), display name (shown in graphical interface) and component type (C,Q or S - see the \ref userTransmissionLineElementMethod "transmission line element method"). It is also possible to add ports, parameters, utility functions and static variables. Finally, the code for the component can be written in two ways, either directly from C++ code, or from algebraic equations using a subset of the Modelica language.

When writing C++ code, there are three functions available: Initialize, SimulateOneTimeStep and Finalize. Initialize are ran before the first time step of the simulation, SimulateOneTimeStep is ran every time step, and finalize are ran after the simulation is finished. Available and sought parameters are displayed above the code boxes. When clicking compile, the component will be converted to Hopsan interface syntax and compiled to an external library.

The other option is to use equations. This function is currently an experimental feature, and full functionality is not guaranteed. Equation-based modeling has several advantages over plain code modeling. It allows equations written in arbitary ways, i.e. more than one variable on the left side. Equations can also be written in any order, as long as the number of equations equals the number of unknown variables. The language used is a subset of Modelica. It allows most basic functionality in the equation section. There is also an algorithm section, that will be executed prior to the equation solver each time step. This section does not support all modelica algorithm functionalities, and is basically intended only for defining explicit expressions that does not need to be part of the equation system. When compiling, a symbolic Jacobian matrix is generated and displayed in a popup window. This is then transformed to Hopsan syntax, together with a fixed-step equation system solver.

Generated components are loaded automatically into a "Generated Component" library.

\page generating-components-mathematica Generating Components From Mathematica
This feature is not implemented in the current version of Hopsan. In future releases it will be possible to automatically generate components from equations in Mathematica.

\page unittest-components Model and Component Unit-Testing
When you have finished a component and/or model and you are satisfied with the simulation results you can save you model and some of the simulation results
as a test model. You can later run this model again and automatically compare the simulation results. This is very important if you want to make sure that 
your component and models do not change their behaviour when new versions of Hopsan are released.

\section unittest-components_howtocreate How to Create a Validation Model
-# Open your model in HopsanGUI and simulate it.
  -# Add the variables (from ports) that you want to use as validation data to a plot window.
  -# Export the data as HVC (Hopsan Validation Configuration) and CSV (Comma Separated Values) files. The column order in the csv file is determined by the order you added curves.
-# The generated hvc file contains default entries. You may want to manually edit it, see format description below.
-# Store the model, dataset and hvc file in  a safe place. Remember that you can not make any more changes (that affect simulation results) to the model file.

\section unittest-components_howtotest How to Test a Validation Model
-# Use the HopsanCLI (Hopsan CommandLineInterface) with the -t (for test) switch according to:
  -# Windows: HopsanCLI.exe -t "MyHVCFile.hvc"
  -# Ubuntu:  ./HopsanCLI -t "MyHVCFile.hvc"
-# If you want to automatically test multiple models, then you should write a script that goes through all of your hvc files.

\section unittest-components_hvc-format The HVC (Hopsan Validation Configuration) Format
This is an example HVC File. Note that you can have multiple <validation> <component> <port> <variable> tags to perform multiple tests from the same configuration file.

\verbatim
<?xml version="1.0" encoding="UTF-8"?>
<hopsanvalidationconfiguration hvcversion="0.1">
  <validation>
    <!--Optional path to model file, default is to use the same name (excluding ext) and path as this file-->
    <modelfile>../Example Models/Position Servo.hmf</modelfile>
    <parameterset></parameterset>
    <component name="Translational Mass">
      <port name="P2">
        <!--Optional path to csv file, default is to use the same name (excluding ext) and path as this file-->
        <csvfile></csvfile>
        <variable name="Position">
          <!-- Optional csvfile override for variable -->
          <!-- <csvfile></csvfile> -->
          <!--Column indexing begins at 0. Time vector is usualy at 0--> 
          <column>1</column> 
          <!--Tolerance, allowed deviation 0.01==1%-->
          <tolerance>0.01</tolerance>
        </variable>
      </port>
    </component>
  </validation>
</hopsanvalidationconfiguration>
\endverbatim

*/
}

