namespace hopsan::Component {
/*!
\page userCustomComponents Custom Components & Libraries

-# \subpage introduction-component-libraries \n
-# \subpage creating-modifying-component-appearance \n
-# \subpage writing-components \n
-# \subpage generating-components-mathematica \n

\page introduction-component-libraries Introduction to Component Libraries

Hopsan uses pre-compiled components. An external component library can be loaded in the program by clicking on the Load External Library icon, in the bottom of the library widget.

\htmlonly
<table border="0">
<tr>
<td>&nbsp;&nbsp;&nbsp;<img src="../../graphics/loadlibrary_icon.png" border=0>
</td>
<td><b>Load External Library</b></td>
</tr>
</table>
\endhtmlonly

A Hopsan component library consists of at least three types of files.
-# The compiled component library code as a .\b dll Windows (Dynamic Link Library) file or as a .\b so (Shared Object) file (Linux/Mac).
-# A set of .\b xml files that describes the graphical appearance of each component.
-# A set of .\b svg (Scalable Vector Graphics) files containing component icon graphics.

There needs to be one .xml file for every component in the library but .svg files can be shared if needed. All components should however be compiled into one single .dll/.so file.
A library typically consists of a directory, containing one .dll/.so file and the .xml and .svg files. Subdirectories containing the .xml and .svg files can be used to create sub categories in the library. The directory hierarchy will be shown in the Hopsan GUI Component Library Widget.

If you have access to the component library source code some additional important files should also be mentioned.
-# One \e "libraryName.cc" file. This is the source code file that is compiled into the .dll/.so .
-# One or several \e "componentName.hpp" files containing the component source code.
-# A project file, or a so called Makefile (build script) that is needed for building the code into the .dll/.so.

If you are only a user of the library you can ignore these additional files, component developers should refer to \link writing-components Writing Components in C++ \endlink 

\page creating-modifying-component-appearance Create or Modify Component Appearance

\section component_svg Graphical Icons (.svg)
Icons for the graphical interface are stored in the Scalable Vector Graphics format. A good tool, which is free and open-source, for creating and editing such files is Inkscape. If you want to use bitmaps graphics, .jpg, .png or similar formats, such graphics can be embedded in a .svg file.

\htmlonly
<a href="http://inkscape.org/">Inkscape Webpage</a>
\endhtmlonly

\section component_xml Appearance Description Files (.xml)
Information about the component for the graphical interface, such as icon, port positions and component name, is stored in a .xml file. This file contains information about the component that is not part of the actual simulation code. This information can be changed without the need to recompile the actual component code. A typical appearance file looks like this:

\verbatim
<?xml version="1.0" encoding="UTF-8"?>
<hopsanobjectappearance version="0.3">
  <modelobject typename="HydraulicLaminarOrifice" displayname="Laminar Orifice">
    <icons>
      <icon type="iso" path="laminarorifice_iso.svg" iconrotation="ON" scale="1.0"/>
      <icon type="user" path="laminarorifice_user.svg" iconrotation="ON" scale="1.0"/>
    </icons>
    <help>
      <text>Help Text</text>
      <picture>helpPicture.svg</picture>
    </help>
    <ports>
      <port name="P1" x="1.0" y="0.5" a="0" visible="true"/>
      <port name="P2" x="0.0" y="0.5" a="180" visible="true"/>
      <port name="Kc" x="0.5" y="0.0" a="270" visible="true">
        <description>The orifice coefficient</description>
      </port>
    </ports>
  </modelobject>
</hopsanobjectappearance>
\endverbatim

The first line contains basic information about the XML code, and should always look the same. A description of the remaining tags follows:

- \b hopsanobjectappearance Main tag for appearance file
  - \b version Should always be 0.3 with this XML layout
- \b modelobject Main tag for the component
  - \b typename Name of the component as registered in the simulation core, see \link writing-components Writing Components \endlink. (Required)
  - \b displayname Name for the component shown in the graphical interface. (If omitted typename will be used)
- \b icons Contains information about icons. At least one type, user or iso is required.
  - \b type The icon type, \e user or \e iso (ISO 1219)
  - \b path Relative path from the .xml file to the .svg
  - \b iconrotation Tells whether or not the icon rotates when the component is rotated in the workspace
  - \b scale Lets you adjust the scale of the .svg graphics (without modifying the actual .svg file) (default=1.0 if omitted)
- \b help Allows you to specify help information explaining the function of the component. (Optional)
  - \b text The help text. (Optional)
  - \b picture The path to the .svg help picture. (Optional)
- \b ports Defines the positions and orientations for each port (Required for each port)
  - \b name Name of the port as defined in the code
  - \b x X-position fraction of component icon width (0 = left, 1 = right)
  - \b y Y-position fraction of component icon height (0 = top, 1 = bottom)
  - \b a Angle of port, 0 = right, 90 = down, 180 = left, 270 = up, ports shall normally point outwards from the component
  - \b visible Is the port is visible by default, \e true or \e false. A hidden port is never shown. (If omitted defaults to true)
  - \b description A description text (help text) for the port. (Optional)



\page writing-components Writing Components in C++

\section writingcomponents_introduction-writing-components Introduction Writing Custom Components 
The majority of the Hopsan component code is contained within the HopsanCore. When the user is creating a new component only the parts which make the new component unique needs to be specified. All other functionality is inherited from the base implementation in the HopsanCore. The code that is written for the new components must be compiled into the .dll/.so file. This file will contain the runtime executable code for the new components. While simulating, Hopsan will call functions in this file each time step.

The compiled library file can include one or several new components. It must also include two mandatory functions used by the HopsanCore to get information and to register the contents of the library once it is loaded.

If you have not already done so, read the \link introduction-component-libraries \endlink for a description of the library files.

\section writingcomponents_exampleComponentLibrary The Example Component Library
The examples bellow are based on the exampleComponentLibrary that should be included with your version of Hopsan. These examples contains subsets of the original files. Also read the original files for their full content. They also include additional comments. When creating a new component library, use the example files as a getting started template.

\section writingcomponents_prerequisites Prerequisites
  - Qt Creator
  - MinGW32 Compiler (MS Windows) or GNU GCC (Linux)
  - Basic knowledge of C++
  - Basic knowledge of TLM modeling

The exampleComponentLibrary project file is specific for the Qt Creator C++ IDE but technically it is possible to use any IDE (code writing software). Knowledge about TLM is not required for writing arithmetic components. See \link userTransmissionLineElementMethod the Transmission Line Element Method \endlink for more information.

If you install the Qt SDK you will get Qt Creator and the MinGW32 compiler. You do not need to install the entire Qt SDK. See this screenshot for an example on the things you need to be able to build hopsan external libs.
\htmlonly
  <br><a href="../../graphics/QtSDK_custom_install_options.png"><img src="../../graphics/QtSDK_custom_install_options.png" width=100 border=0></a><br>
\endhtmlonly


\section writingcomponents_libraryfiles Component Library Project Files

\subsection writingcomponents_file_pro exampleComponentLib.pro
This is the project file for Qt Creator. If you are using a different coding environment, you need to create a similar file for that environment. It is also possible to write a custom make file manually.  

Three modifications is required in this files. First of all the \b INCLUDEPATH must be changed so that it points to the "include" folder in the Hopsan installation. Similarly, the \b LIBS path must point to the "bin" folder in the installation directory. Finally, the relative path to all components source files in the library must be specified under HEADERS.

\code
QT -= core gui
TEMPLATE = lib

TARGET = exampleComponentLib
DESTDIR = $${PWD}/
INCLUDEPATH *= $${PWD}/../../HopsanCore/include/
LIBS *= -L$${PWD}/../../bin

CONFIG(debug, debug|release) {
    LIBS *= -lHopsanCore_d
    DEFINES *= DEBUGCOMPILING
}
CONFIG(release, debug|release) {
    LIBS *= -lHopsanCore
    DEFINES *= RELEASECOMPILING
}

SOURCES += \
    exampleComponentLib.cc

HEADERS += \
    component_code/MyExampleVolume.hpp \
    component_code/MyExampleOrifice.hpp

OTHER_FILES +=
\endcode

\subsection writingcomponents_file_cc exampleComponentLib.cc
This file contains code that is used to register you library components in the Hopsan simulation core. Two modifications are required. 
- First of all, all component code files must be included. (They will be copied into this file during compilation)
- Second, each component needs to be registered in the simulation core by the pComponentFactory->registerCreatorFunction("KeyValue", CreatorFunction) lines.\n
The \e "KeyValue" argument must be a unique typename that identifies you component. The \e CreatorFunction argument is the Creator function in each component.
- Theird, Make sure that you write a unique libName (as a string) in the get_hopsan_info function. Leave the two last lines as they are.

\code
#include "component_code/MyExampleOrifice.hpp"
#include "component_code/MyExampleVolume.hpp"

#include "ComponentEssentials.h"
using namespace hopsan;

extern "C" DLLEXPORT void register_contents(ComponentFactory* pComponentFactory, NodeFactory* pNodeFactory)
{
    pComponentFactory->registerCreatorFunction("MyExampleOrifice", MyExampleOrifice::Creator);
    pComponentFactory->registerCreatorFunction("MyExampleVolume", MyExampleVolume::Creator);
}

extern "C" DLLEXPORT void get_hopsan_info(HopsanExternalLibInfoT *pHopsanExternalLibInfo)
{
    pHopsanExternalLibInfo->libName = (char*)"HopsanExampleComponentLibrary";
    pHopsanExternalLibInfo->hopsanCoreVersion = (char*)HOPSANCOREVERSION;
    pHopsanExternalLibInfo->libCompiledDebugRelease = (char*)DEBUGRELEASECOMPILED;
}
\endcode

\subsection writingcomponents_file_svg_xml XML and SVG files
The XML files contain the appearance description, and the SVG files are the icons, see \link creating-modifying-component-appearance Creating or Modifying Component Appearance \endlink.

\subsection writingcomponents_file_hpp MyExampleOrifice.hpp & MyExampleVolume.hpp
These files contains the source code for the components, see below.


\section writingcomponents_codestructure Component Code Structure
Components are written in header-only C++ files (.hpp). Let's take a look at "MyExampleOrifice.hpp". The file consist of the following parts:

This first line includes the essential functions for the component from the simulation core. It may be necessary to include more files, for example "ComponentUtilities.h" for accessing built-in component utilities in Hopsan, or external header files.
\dontinclude MyExampleOrifice.hpp
\skipline #include

Next the component class is declared. We inherit from a \b ComponentQ as this is a Q-type component.
This could also be \b ComponentC or \b ComponentS for C-type or Signal-type components.
\skipline class MyExampleOrifice

First the \e private part of the component is specified. Here we declare member variables, (variables that should be persistent in the component).
In this case we have a restriction coefficient called \b mKc and two port pointers called \b mpP1 and \b mpP2 ("m" is an abbreviation of "member" and "mp" means "member and pointer").
\skip private:
\until Port

In the \e public part we first define a static creator function, which is used to create instances of the component in the simulation core. Nothing needs to be changed except the name of the class.
\skip static Component *Creator()
\until }

The second member function you need to define is the so called \e Constructor for the class. This function is run once every time a new object of the class is created (added to the model).
The constructor is used to configure the component and to set default values of member variables.
First we give the restrictor coefficient a default value. Then we create the ports used for communication with surrounding components, in this case two hydraulic powerports.
Finally we register the restrictor coefficient as parameter with a name, description and unit. This will make it available to the user in the graphical interface. 
\skip MyExampleOrifice() : ComponentQ()
\until }

The following functions are available for port creation:
You need to specify a unique (within the component) portname, which node type it should use, and whether a connection to it is Port::REQUIRED or Port::NOTREQUIRED. If the final argument is omitted it will default to REQUIRED.
\code 
Port* addPowerPort(const string portName, const string nodeType, const Port::ReqConnEnumT reqConnect=Port::REQUIRED);
Port* addReadPort(const string portName, const string nodeType, const Port::ReqConnEnumT reqConnect=Port::REQUIRED);
Port* addWritePort(const string portName, const string nodeType, const Port::ReqConnEnumT reqConnect=Port::REQUIRED);
Port* addPowerMultiPort(const string portName, const string nodeType, const Port::ReqConnEnumT reqConnect=Port::REQUIRED);
Port* addReadMultiPort(const string portname, const string nodetype, const Port::ReqConnEnumT reqConnect=Port::REQUIRED);
\endcode

The currently available built-in node types can be found here: \ref Nodes "NodeTypes"\n
New node types can be added through external libraries, but this should be avoided if possible.

For parameter registration the following functions are available. The correct register function will automatically be selected depending on the value type.
The register functions will register the given name, unit and description and connect this information to a pointer pointing at the variable you specify as the \b rValue argument.
\code
void registerParameter(const string name, const string description, const string unit, double &rValue);
void registerParameter(const string name, const string description, const string unit, string &rValue);
void registerParameter(const string name, const string description, const string unit, bool &rValue);
\endcode

For more useful functions see \ref ConvenientFunctions

The next member function that must be defined is the \e Initialize function.
This function is run once before the first time step in the simulation. As this function is run after connections have been establish you can read or write to/from connected components. 
If needed you can use this information to initialize your component properly. This is also the place to allocate aditional memory if needed. 
In this function you also typically initialize more advanced utilities such as (but not limited to) Delays, Integrators or Transfer-functions. 
In this example case we have nothing that needs to be initialized.
\skip void initialize()
\until }

 
The next function is the most important member function. It contains the model equations that are executed each time step.
We begin with creating local variables from the connected ports, and we end by writing back the new values we have calculated.
This procedure is intended to make the actual equations more readable. The middle part is the actual equations. 
In this case we calculate flow and pressure through the orifice from wave variables and impedance in the neighbouring C-type components.
\skip void simulateOneTimestep()
\until }

The last member function is optional. It is only useful if you want some code to be run after simulation has finished.
This is usually only needed if you want to free memory that you have additionally allocated in the \e initialize function.
\skip void finalize()
\until }

\section writingcomponents_compilation Compilation

When everything is finished, the project must be compiled. It is necessary to use the MinGW32 compiler, because Hopsan is compiled with this compiler. The project must also be compiled in "release" mode.
Compilation goes through two phases, first the .cc file or files are compiled and then they are linked into one .dll or .so file.

If you have written something wrong in your code you may get a compilation error that you need to correct. Usually these error messages are quite descriptive.
You may also get linker errors which are usually a bit more difficult to understand if you are not used to compiling you own code.

If you get something similar to the following error message: \"<tt>cannot find -lHopsanCore</tt>\" you have probably set the LIBS path incorrectly in your project file.\n

If compilation was successful, a .dll or.so file will appear in the directory. It should now be possible to load the library from Hopsan, by pointing out the directory - see \ref introduction-component-libraries "Introduction".

\page generating-components-mathematica Generating Components From Mathematica
This feature is not implemented in the current version of Hopsan. In future releases it will be possible to automatically generate components from equations in Mathematica.
*/
}

