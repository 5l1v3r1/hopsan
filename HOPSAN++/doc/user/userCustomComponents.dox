/*!
\page userCustomComponents Custom Components & Libraries

-# \subpage introduction-component-libraries \n
-# \subpage creating-modifying-component-appearance \n
-# \subpage writing-components \n
-# \subpage generating-components-mathematica \n

\page introduction-component-libraries Introduction to Component Libraries

Hopsan uses pre-compiled components. An external component library can be loaded in the program by clicking on the Load External Library icon, in the bottom of the library widget.

\htmlonly
<table border="0">
<tr>
<td>&nbsp;&nbsp;&nbsp;<img src="../../graphics/loadlibrary_icon.png" border=0>
</td>
<td><b>Load External Library</b></td>
</tr>
</table>
\endhtmlonly

A Hopsan component library consists of at least three types of files.
-# The compiled component library code as a .\b dll Windows (Dynamic Link Library) file or as a .\b so (Shared Object) file (Linux/Mac).
-# A set of .\b xml files that describes the graphical appearance of each component.
-# A set of .\b svg (Scalable Vector Graphics) files containing component icon graphics.

There needs to be one .xml file for every component in the library but .svg files can be shared if needed. All components should however be compiled into one single .dll/.so file.
A library typically consists of a directory, containing one .dll/.so file and the .xml and .svg files. Subdirectories containing the .xml and .svg files can be used to create sub categories in the library. The directory hierarchy will be shown in the Hopsan GUI Component Library Widget.

If you have access to the component library source code some additional important files should also be mentioned.
-# One \e "libraryName.cc" file. This is the source code file that is compiled into the .dll/.so .
-# One or several \e "componentName.hpp" files containing the component source code.
-# A project file, or a so called Makefile (build script) that is needed for building the code into the .dll/.so.

If you are only a user of the library you can ignore these additional files, component developers should refer to \link writing-components Writing Components in C++ \endlink 

\page creating-modifying-component-appearance Create or Modify Component Appearance

\section component_svg Graphical Icons (.svg)
Icons for the graphical interface are stored in the Scalable Vector Graphics format. A good tool, which is free and open-source, for creating and editing such files is Inkscape. If you want to use bitmaps graphics, .jpg, .png or similar formats, such graphics can be embedded in a .svg file.

\htmlonly
<a href="http://inkscape.org/">Inkscape Webpage</a>
\endhtmlonly

\section component_xml Appearance Description Files (.xml)
Information about the component for the graphical interface, such as icon, port positions and component name, is stored in a .xml file. This file contains information about the component that is not part of the actual simulation code. This information can be changed without the need to recompile the actual component code. A typical appearance file looks like this:

\verbatim
<?xml version="1.0" encoding="UTF-8"?>
<hopsanobjectappearance version="0.3">
  <modelobject typename="HydraulicLaminarOrifice" displayname="Laminar Orifice">
    <icons>
      <icon type="iso" path="laminarorifice_iso.svg" iconrotation="ON" scale="1.0"/>
      <icon type="user" path="laminarorifice_user.svg" iconrotation="ON" scale="1.0"/>
    </icons>
    <help>
      <text>Help Text</text>
      <picture>helpPicture.svg</picture>
    </help>
    <ports>
      <port name="P1" x="1.0" y="0.5" a="0"/>
      <port name="P2" x="0.0" y="0.5" a="180"/>
      <port name="Kc" x="0.5" y="0.0" a="270"/>
    </ports>
  </modelobject>
</hopsanobjectappearance>
\endverbatim

The first line contains basic information about the XML code, and should always look the same. A description of the remaining tags follows:

- \b hopsanobjectappearance Main tag for appearance file
  - \b version Should always be 0.3 with this XML layout
- \b modelobject Main tag for the component
  - \b typename Name of the component as registered in the simulation core, see \link writing-components Writing Components \endlink. (Required)
  - \b displayname Name for the component shown in the graphical interface. (If omitted typename will be used)
- \b icons Contains information about icons. At least one type, user or iso is required.
  - \b type The icon type, \e user or \e iso (ISO 1219)
  - \b path Relative path from the .xml file to the .svg
  - \b iconrotation Tells whether or not the icon rotates when the component is rotated in the workspace
  - \b scale Lets you adjust the scale of the .svg graphics (without modifying the actual .svg file) (default=1.0 if omitted)
- \b help Allows you to specify help information explaining the function of the component. (Optional)
  - \b text The help text. (Optional)
  - \b picture The path to the .svg help picture. (Optional)
- \b ports Defines the positions and orientations for each port (Required for each port)
  - \b name Name of the port as defined in the code
  - \b x X-position in percent of component icon (0 = left, 1 = right)
  - \b y Y-position in percent of component icon (0 = top, 1 = bottom)
  - \b a Angle of port, 0 = right, 90 = down etc., port shall normally point outwards from the component



\page writing-components Writing Components in C++

\section writingcomponents_introduction-writing-components Introduction Writing Custom Components 
The majority of the Hopsan component code is contained within the HopsanCore. When the user is creating a new component only the parts which make the new component unique needs to be specified. All other functionality is inherited from the base implementation in the HopsanCore. The code that is written for the new components must be compiled into the .dll/.so file. This file will contain the runtime executable code for the new components. While simulating, Hopsan will call functions in this file each time step.

The compiled library file can include one or several new components. It must also include two mandatory functions used by the HopsanCore to get information and to register the contents of the library once it is loaded.

If you have not already done so, read the \link introduction-component-libraries \endlink for a description of the library files.

\section writingcomponents_exampleComponentLibrary The Example Component Library
The examples bellow are based on the exampleComponentLibrary that should be included with your version of Hopsan. These examples contains subsets of the original files. Also read the original files for their full content. They also include additional comments. When creating a new component library, use the example files as a getting started template.

\section writingcomponents_prerequisites Prerequisites
  - Qt Creator
  - MinGW32 Compiler (MS Windows) or GNU GCC (Linux)
  - Basic knowledge of C++
  - Basic knowledge of TLM modeling

The exampleComponentLibrary project file is specific for the Qt Creator C++ IDE but technically it is possible to use any IDE (code writing software). Knowledge about TLM is not required for writing arithmetic components. See \link userTransmissionLineElementMethod the Transmission Line Element Method \endlink for more information.

\section writingcomponents_libraryfiles Component Library Project Files

\subsection writingcomponents_file_pro exampleComponentLib.pro
This is the project file for Qt Creator. If you are using a different coding environment, you need to create a similar file for that environment. It is also possible to write a custom make file manually.  

Three modifications is required in this files. First of all the \b INCLUDEPATH must be changed so that it points to the "include" folder in the Hopsan installation. Similarly, the \b LIBS path must point to the "bin" folder in the installation directory. Finally, the relative path to all components source files in the library must be specified under HEADERS.

\code
QT -= core gui
TEMPLATE = lib

TARGET = exampleComponentLib
DESTDIR = $${PWD}/
INCLUDEPATH *= $${PWD}/../../HopsanCore
LIBS *= -L$${PWD}/../../bin

CONFIG(debug, debug|release) {
    LIBS *= -lHopsanCore_d
    DEFINES *= DEBUGCOMPILING
}
CONFIG(release, debug|release) {
    LIBS *= -lHopsanCore
    DEFINES *= RELEASECOMPILING
}

SOURCES += \
    exampleComponentLib.cc

HEADERS += \
    component_code/MyExampleVolume.hpp \
    component_code/MyExampleOrifice.hpp

OTHER_FILES +=
\endcode

\subsection writingcomponents_file_cc exampleComponentLib.cc
This file contains code that is used to register you library components in the Hopsan simulation core. Two modifications are required. 
- First of all, all component code files must be included. (They will be copied into this file during compilation)
- Second, each component needs to be registered in the simulation core by the pComponentFactory->registerCreatorFunction("KeyValue", CreatorFunction) lines.\n
The \e "KeyValue" argument must be a unique typename that identifies you component. The \e CreatorFunction argument is the Creator function in each component.

\code
#include "component_code/MyExampleOrifice.hpp"
#include "component_code/MyExampleVolume.hpp"

#include "ComponentEssentials.h"
using namespace hopsan;

extern "C" DLLEXPORT void register_contents(ComponentFactory* pComponentFactory, NodeFactory* pNodeFactory)
{
    pComponentFactory->registerCreatorFunction("MyExampleOrifice", MyExampleOrifice::Creator);
    pComponentFactory->registerCreatorFunction("MyExampleVolume", MyExampleVolume::Creator);
}

extern "C" DLLEXPORT void get_hopsan_info(HopsanExternalLibInfoT *pHopsanExternalLibInfo)
{
    pHopsanExternalLibInfo->hopsanCoreVersion = (char*)HOPSANCOREVERSION;
    pHopsanExternalLibInfo->libCompiledDebugRelease = (char*)DEBUGRELEASECOMPILED;
}
\endcode

\subsection writingcomponents_file_svg_xml XML and SVG files
The XML files contain the appearance description, and the SVG files are the icons, see \link creating-modifying-component-appearance Creating or Modifying Component Appearance \endlink.

\subsection writingcomponents_file_hpp MyExampleOrifice.hpp & MyExampleVolume.hpp
These files contains the source code for the components, see below.


\section writingcomponents_codestructure Component Code Structure
Components are written in header-only C++ files (.hpp). Let's take a look at "MyExampleOrifice.hpp". The file consist of the following parts:

\code
#include "ComponentEssentials.h"
\endcode

This line includes the essential functions for the component from the simulation core. It may be necessary to include more files, for example "ComponentUtilities.h" for accessing built-in component utilities in Hopsan, or external header files.

\code
class MyExampleOrifice : public ComponentQ
\endcode

Here the class is declared. ComponentQ means that this is a Q-type component. It could also be ComponentC or ComponentS for C-type or signal components.

\code
double mKc;
Port *mpP1, *mpP2;
\endcode

This is the member variables in the class. In this case we have a restriction coefficient called mKc and two ports called mpP1 and mpP2 ("m" is an abbreviation of "member" and "mp" means "member pointer").

\code
static Component *Creator()
{
    return new MyExampleOrifice();
}
\endcode

Here we see the creator function, which is used to generate instances of the component in the simulation core. Nothing needs to be changed except the name of the class.

\code
MyExampleOrifice() : ComponentQ()
{
    // Set initial member variable values
    mKc = 1.0e-11;

    // Add ports to the component
    mpP1 = addPowerPort("P1", "NodeHydraulic");
    mpP2 = addPowerPort("P2", "NodeHydraulic");

    // Register component parameters that can be changed by the user
    registerParameter("Kc", "Pressure-Flow Coefficient", "[m^5/Ns]", mKc);
}
\endcode

This is the constructor for the class, which is ran every time a new component is created (added to the model). First we give the restrictor coefficient a default value. Then we register the parameter with a name, a description and a unit. This will make it available to the user in the graphical interface. Finally we define the ports, in this case we want two hydraulic power ports. The following port types and node types are available:

Port types
  - addPowerPort
  - addPowerMultiPort
  - addReadPort
  - addReadMultiPort
  - addWritePort

Node types
  - NodeSignal
  - NodeMechanic
  - NodeMechanicRotational
  - NodeHydraulic
  - NodePneumatic
  - NodeElectric

Node types can be extended, these are just the current built-in types.

\code
void initialize()
{
    //Nothing to initialize
}
\endcode

The initialize function is ran before the first time step in the simulation. In this example case we have nothing that needs to be initialized. 

\code
void simulateOneTimestep()
{
    //Get variable values from nodes
    double c1 = mpP1->readNode(NodeHydraulic::WAVEVARIABLE);
    double Zc1 = mpP1->readNode(NodeHydraulic::CHARIMP);
    double c2 = mpP2->readNode(NodeHydraulic::WAVEVARIABLE);
    double Zc2 = mpP2->readNode(NodeHydraulic::CHARIMP);

    //Orifice equations
    double q2 = mKc*(c1-c2)/(1.0+mKc*(Zc1+Zc2));
    double q1 = -q2;
    double p1 = c1 + q1*Zc1;
    double p2 = c2 + q2*Zc2;

    //Write new values to nodes
    mpP1->writeNode(NodeHydraulic::PRESSURE, p1);
    mpP1->writeNode(NodeHydraulic::FLOW, q1);
    mpP2->writeNode(NodeHydraulic::PRESSURE, p2);
    mpP2->writeNode(NodeHydraulic::FLOW, q2);
}
\endcode

This is the most important code, the model equations that are executed each time step. We begin with creating local variables from the node pointers, and we end by writing back the values we have calculated. This procedure is intended to make the actual equations more readable. The middle part is the actual equations. In this case we calculate flow and pressure through the orifice from wave variables and impedance in the neighbouring C-type components.

\section writingcomponents_compilation Compilation

When everything is finished, the project must be compiled. It is necessary to use the MinGW32 compiler, because Hopsan is compiled with this. The project must also be compiled in "release" mode.

If compilation was successful, a .dll file will appear in the directory. It should now be possible to load the library from Hopsan, by pointing out the directory - see \link userCustomComponents Introduction \endlink.

\page generating-components-mathematica Generating Components From Mathematica
This feature is not implemented in the current version of Hopsan. In future releases it will be possible to automatically generate components from equations in Mathematica.
*/

