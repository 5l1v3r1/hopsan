#ifndef MECHANICROTSHAFT_HPP_INCLUDED
#define MECHANICROTSHAFT_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file MechanicRotShaft.hpp
//! @author Petter Krus <petter.krus@liu.se>
//! @date Thu 28 Jun 2012 09:14:24
//! @brief Rotational shaft with torsional spring
//! @ingroup MechanicComponents
//!
//This component is generated by COMPGEN for HOPSAN-NG simulation 
//from 
/*{, C:, Documents and Settings, petkr14, My Documents, \
CompgenNG}/Mechanic1DNG.nb*/

using namespace hopsan;

class MechanicRotShaft : public ComponentC
{
private:
     double mKs;
     double malpha;
     Port *mpPmr1;
     Port *mpPmr2;
     int mNstep;
     //Port Pmr1 variable
     double tormr1;
     double thetamr1;
     double wmr1;
     double cmr1;
     double Zcmr1;
     double eqInertiamr1;
     //Port Pmr2 variable
     double tormr2;
     double thetamr2;
     double wmr2;
     double cmr2;
     double Zcmr2;
     double eqInertiamr2;
     //inputVariables
     //outputVariables
     //LocalExpressions variables
     double cmr10;
     double cmr20;
     //Expressions variables
     double cmr1f;
     double cmr2f;
     //Port Pmr1 pointer
     double *mpND_tormr1;
     double *mpND_thetamr1;
     double *mpND_wmr1;
     double *mpND_cmr1;
     double *mpND_Zcmr1;
     double *mpND_eqInertiamr1;
     //Port Pmr2 pointer
     double *mpND_tormr2;
     double *mpND_thetamr2;
     double *mpND_wmr2;
     double *mpND_cmr2;
     double *mpND_Zcmr2;
     double *mpND_eqInertiamr2;
     //Delay declarations
     //inputVariables pointers
     //outputVariables pointers
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new MechanicRotShaft();
     }

     void configure()
     {
        const double Ks = 1000.;
        const double alpha = 0.9;

        mNstep=9;
        mKs = Ks;
        malpha = alpha;

        //Add ports to the component
        mpPmr1=addPowerPort("Pmr1","NodeMechanicRotational");
        mpPmr2=addPowerPort("Pmr2","NodeMechanicRotational");

        //Add inputVariables ports to the component

        //Add outputVariables ports to the component

        //Register changable parameters to the HOPSAN++ core
        registerParameter("Ks", "Spring constant", "Nm/rad", mKs);
        registerParameter("alpha", "damping factor", "", malpha);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Port Pmr1
        mpND_tormr1=getSafeNodeDataPtr(mpPmr1, \
NodeMechanicRotational::Torque);
        mpND_thetamr1=getSafeNodeDataPtr(mpPmr1, \
NodeMechanicRotational::Angle);
        mpND_wmr1=getSafeNodeDataPtr(mpPmr1, \
NodeMechanicRotational::AngularVelocity);
        mpND_cmr1=getSafeNodeDataPtr(mpPmr1, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcmr1=getSafeNodeDataPtr(mpPmr1, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiamr1=getSafeNodeDataPtr(mpPmr1, \
NodeMechanicRotational::EquivalentInertia);
        //Port Pmr2
        mpND_tormr2=getSafeNodeDataPtr(mpPmr2, \
NodeMechanicRotational::Torque);
        mpND_thetamr2=getSafeNodeDataPtr(mpPmr2, \
NodeMechanicRotational::Angle);
        mpND_wmr2=getSafeNodeDataPtr(mpPmr2, \
NodeMechanicRotational::AngularVelocity);
        mpND_cmr2=getSafeNodeDataPtr(mpPmr2, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcmr2=getSafeNodeDataPtr(mpPmr2, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiamr2=getSafeNodeDataPtr(mpPmr2, \
NodeMechanicRotational::EquivalentInertia);
        //Read inputVariables pointers from nodes
        //Read outputVariable pointers from nodes

        //Read variables from nodes
        //Port Pmr1
        tormr1 = (*mpND_tormr1);
        thetamr1 = (*mpND_thetamr1);
        wmr1 = (*mpND_wmr1);
        cmr1 = (*mpND_cmr1);
        Zcmr1 = (*mpND_Zcmr1);
        eqInertiamr1 = (*mpND_eqInertiamr1);
        //Port Pmr2
        tormr2 = (*mpND_tormr2);
        thetamr2 = (*mpND_thetamr2);
        wmr2 = (*mpND_wmr2);
        cmr2 = (*mpND_cmr2);
        Zcmr2 = (*mpND_Zcmr2);
        eqInertiamr2 = (*mpND_eqInertiamr2);

        //Read inputVariables from nodes

        //Read outputVariables from nodes

        //InitialExpressions
        cmr1 = tormr1 - (mKs*mTimestep*wmr1)/(1 - malpha);
        cmr2 = tormr2 - (mKs*mTimestep*wmr2)/(1 - malpha);
        cmr1f = tormr1;
        cmr2f = tormr2;

        //LocalExpressions
        cmr10 = cmr2 + (2*mKs*mTimestep*wmr2)/(1 - malpha);
        cmr20 = cmr1 + (2*mKs*mTimestep*wmr1)/(1 - malpha);

        //Initialize delays

     }
    void simulateOneTimestep()
     {
        //Read variables from nodes
        //Port Pmr1
        tormr1 = (*mpND_tormr1);
        thetamr1 = (*mpND_thetamr1);
        wmr1 = (*mpND_wmr1);
        eqInertiamr1 = (*mpND_eqInertiamr1);
        //Port Pmr2
        tormr2 = (*mpND_tormr2);
        thetamr2 = (*mpND_thetamr2);
        wmr2 = (*mpND_wmr2);
        eqInertiamr2 = (*mpND_eqInertiamr2);

        //Read inputVariables from nodes

        //LocalExpressions
        cmr10 = cmr2 + (2*mKs*mTimestep*wmr2)/(1 - malpha);
        cmr20 = cmr1 + (2*mKs*mTimestep*wmr1)/(1 - malpha);

          //Expressions
          cmr1 = cmr1f;
          cmr2 = cmr2f;
          cmr1f = cmr10*(1 - malpha) + cmr1f*malpha;
          cmr2f = cmr20*(1 - malpha) + cmr2f*malpha;
          Zcmr1 = (mKs*mTimestep)/(1 - malpha);
          Zcmr2 = (mKs*mTimestep)/(1 - malpha);

        //Calculate the delayed parts


        //Write new values to nodes
        //Port Pmr1
        (*mpND_cmr1)=cmr1;
        (*mpND_Zcmr1)=Zcmr1;
        //Port Pmr2
        (*mpND_cmr2)=cmr2;
        (*mpND_Zcmr2)=Zcmr2;
        //outputVariables

        //Update the delayed variabels

     }
};
#endif // MECHANICROTSHAFT_HPP_INCLUDED
