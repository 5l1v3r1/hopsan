#ifndef SIGNALATTITUDECONTROL_HPP_INCLUDED
#define SIGNALATTITUDECONTROL_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file SignalAttitudeControl.hpp
//! @author Petter Krus <petter.krus@liu.se>
//! @date Mon 12 Nov 2012 14:13:12
//! @brief Attitude control unit for an aircraft
//! @ingroup SignalComponents
//!
//This component is generated by COMPGEN for HOPSAN-NG simulation 
//from 
/*{, C:, Users, petkr14.IEI, Documents, CompgenNG}/SignalControlAeroNG.nb*/

using namespace hopsan;

class SignalAttitudeControl : public ComponentSignal
{
private:
     double mKphi;
     double mKphipsi;
     double mKelev;
     double mKrud;
     double mKRrud;
     double mu1min;
     double mu1max;
     double mu2min;
     double mu2max;
     double mu3min;
     double mu3max;
     double mU0;
     double mphiref;
     double mthetaref;
     double mpsiref;
     double mphi;
     double mtheta;
     double mpsi;
     double mbeta;
     double mphimax;
     double mRb;
     double mUb;
     Port *mpPphiref;
     Port *mpPthetaref;
     Port *mpPpsiref;
     Port *mpPphi;
     Port *mpPtheta;
     Port *mpPpsi;
     Port *mpPbeta;
     Port *mpPphimax;
     Port *mpPRb;
     Port *mpPUb;
     Port *mpPuaerL;
     Port *mpPuaerR;
     Port *mpPuelev;
     Port *mpPurud;
     int mNstep;
     //inputVariables
     double phiref;
     double thetaref;
     double psiref;
     double phi;
     double theta;
     double psi;
     double beta;
     double phimax;
     double Rb;
     double Ub;
     //outputVariables
     double uaerL;
     double uaerR;
     double uelev;
     double urud;

     //LocalExpressions variables
     double Kv;
     double u1cmin;
     double u1cmax;
     double u2cmin;
     double u2cmax;
     double u3cmin;
     double u3cmax;
     //Expressions variables
     //Delay declarations
     //inputVariables pointers
     double *mpND_phiref;
     double *mpND_thetaref;
     double *mpND_psiref;
     double *mpND_phi;
     double *mpND_theta;
     double *mpND_psi;
     double *mpND_beta;
     double *mpND_phimax;
     double *mpND_Rb;
     double *mpND_Ub;
     //outputVariables pointers
     double *mpND_uaerL;
     double *mpND_uaerR;
     double *mpND_uelev;
     double *mpND_urud;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new SignalAttitudeControl();
     }

     void configure()
     {
        const double Kphi = 3.;
        const double Kphipsi = 2.;
        const double Kelev = 4.;
        const double Krud = 1.;
        const double KRrud = 1.;
        const double u1min = -0.9;
        const double u1max = 0.9;
        const double u2min = -0.7;
        const double u2max = 0.7;
        const double u3min = -0.7;
        const double u3max = 0.7;
        const double U0 = 100.;
        const double phiref = 0.;
        const double thetaref = 0.;
        const double psiref = 0.;
        const double phi = 0.;
        const double theta = 0.;
        const double psi = 0.;
        const double beta = 0.;
        const double phimax = 1.;
        const double Rb = 0.;
        const double Ub = 0.;

        mNstep=9;
        mKphi = Kphi;
        mKphipsi = Kphipsi;
        mKelev = Kelev;
        mKrud = Krud;
        mKRrud = KRrud;
        mu1min = u1min;
        mu1max = u1max;
        mu2min = u2min;
        mu2max = u2max;
        mu3min = u3min;
        mu3max = u3max;
        mU0 = U0;
        mphiref = phiref;
        mthetaref = thetaref;
        mpsiref = psiref;
        mphi = phi;
        mtheta = theta;
        mpsi = psi;
        mbeta = beta;
        mphimax = phimax;
        mRb = Rb;
        mUb = Ub;

        //Add ports to the component

        //Add inputVariables ports to the component
        mpPphiref=addReadPort("Pphiref","NodeSignal", Port::NOTREQUIRED);
        mpPthetaref=addReadPort("Pthetaref","NodeSignal", Port::NOTREQUIRED);
        mpPpsiref=addReadPort("Ppsiref","NodeSignal", Port::NOTREQUIRED);
        mpPphi=addReadPort("Pphi","NodeSignal", Port::NOTREQUIRED);
        mpPtheta=addReadPort("Ptheta","NodeSignal", Port::NOTREQUIRED);
        mpPpsi=addReadPort("Ppsi","NodeSignal", Port::NOTREQUIRED);
        mpPbeta=addReadPort("Pbeta","NodeSignal", Port::NOTREQUIRED);
        mpPphimax=addReadPort("Pphimax","NodeSignal", Port::NOTREQUIRED);
        mpPRb=addReadPort("PRb","NodeSignal", Port::NOTREQUIRED);
        mpPUb=addReadPort("PUb","NodeSignal", Port::NOTREQUIRED);

        //Add outputVariables ports to the component
        mpPuaerL=addWritePort("PuaerL","NodeSignal", Port::NOTREQUIRED);
        mpPuaerR=addWritePort("PuaerR","NodeSignal", Port::NOTREQUIRED);
        mpPuelev=addWritePort("Puelev","NodeSignal", Port::NOTREQUIRED);
        mpPurud=addWritePort("Purud","NodeSignal", Port::NOTREQUIRED);

        //Register changable parameters to the HOPSAN++ core
        registerParameter("Kphi", "Gain roll", "rad", mKphi);
        registerParameter("Kphipsi", "Gain yaw/roll", "rad", mKphipsi);
        registerParameter("Kelev", "Gain tip, default", "rad", mKelev);
        registerParameter("Krud", "Gain yaw, default", "rad", mKrud);
        registerParameter("KRrud", "Gain yaw rate, default", "", mKRrud);
        registerParameter("u1min", "Minium output signal roll", "rad", \
mu1min);
        registerParameter("u1max", "Maximum output signal roll", "rad", \
mu1max);
        registerParameter("u2min", "Minium output signal tip", "rad", \
mu2min);
        registerParameter("u2max", "Maximum output signal tip", "rad", \
mu2max);
        registerParameter("u3min", "Minium output signal yaw", "rad", \
mu3min);
        registerParameter("u3max", "Maximum output signal yaw", "rad", \
mu3max);
        registerParameter("U0", "Reference speed for compensation", "m/s", \
mU0);
        registerParameter("phiref", "Reference signal roll", "rad", mphiref);
        registerParameter("thetaref", "Reference signal tip", "rad", \
mthetaref);
        registerParameter("psiref", "Reference signal yaw", "rad", mpsiref);
        registerParameter("phi", "roll angle", "rad", mphi);
        registerParameter("theta", "tipp angle", "rad", mtheta);
        registerParameter("psi", "yaw angle", "rad", mpsi);
        registerParameter("beta", "side slip angle", "rad", mbeta);
        registerParameter("phimax", "Maximum bank angle for turn", "rad", \
mphimax);
        registerParameter("Rb", "yaw angle rate", "rad/s", mRb);
        registerParameter("Ub", "actual speed", "m/s", mUb);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Read inputVariables pointers from nodes
        mpND_phiref=getSafeNodeDataPtr(mpPphiref, NodeSignal::VALUE,mphiref);
        mpND_thetaref=getSafeNodeDataPtr(mpPthetaref, \
NodeSignal::VALUE,mthetaref);
        mpND_psiref=getSafeNodeDataPtr(mpPpsiref, NodeSignal::VALUE,mpsiref);
        mpND_phi=getSafeNodeDataPtr(mpPphi, NodeSignal::VALUE,mphi);
        mpND_theta=getSafeNodeDataPtr(mpPtheta, NodeSignal::VALUE,mtheta);
        mpND_psi=getSafeNodeDataPtr(mpPpsi, NodeSignal::VALUE,mpsi);
        mpND_beta=getSafeNodeDataPtr(mpPbeta, NodeSignal::VALUE,mbeta);
        mpND_phimax=getSafeNodeDataPtr(mpPphimax, NodeSignal::VALUE,mphimax);
        mpND_Rb=getSafeNodeDataPtr(mpPRb, NodeSignal::VALUE,mRb);
        mpND_Ub=getSafeNodeDataPtr(mpPUb, NodeSignal::VALUE,mUb);
        //Read outputVariable pointers from nodes
        mpND_uaerL=getSafeNodeDataPtr(mpPuaerL, NodeSignal::VALUE);
        mpND_uaerR=getSafeNodeDataPtr(mpPuaerR, NodeSignal::VALUE);
        mpND_uelev=getSafeNodeDataPtr(mpPuelev, NodeSignal::VALUE);
        mpND_urud=getSafeNodeDataPtr(mpPurud, NodeSignal::VALUE);

        //Read variables from nodes

        //Read inputVariables from nodes
        phiref = (*mpND_phiref);
        thetaref = (*mpND_thetaref);
        psiref = (*mpND_psiref);
        phi = (*mpND_phi);
        theta = (*mpND_theta);
        psi = (*mpND_psi);
        beta = (*mpND_beta);
        phimax = (*mpND_phimax);
        Rb = (*mpND_Rb);
        Ub = (*mpND_Ub);

        //Read outputVariables from nodes
        uaerL = mpPuaerL->getStartValue(NodeSignal::VALUE);
        uaerR = mpPuaerR->getStartValue(NodeSignal::VALUE);
        uelev = mpPuelev->getStartValue(NodeSignal::VALUE);
        urud = mpPurud->getStartValue(NodeSignal::VALUE);


        //LocalExpressions
        Kv = Power(mU0,2)/(Power(mU0,2) + Power(Abs(Ub),2));
        u1cmin = Kv*mu1min;
        u1cmax = Kv*mu1max;
        u2cmin = Kv*mu2min;
        u2cmax = Kv*mu2max;
        u3cmin = mu3min;
        u3cmax = mu3max;

        //Initialize delays

     }
    void simulateOneTimestep()
     {
        //Read variables from nodes

        //Read inputVariables from nodes
        phiref = (*mpND_phiref);
        thetaref = (*mpND_thetaref);
        psiref = (*mpND_psiref);
        phi = (*mpND_phi);
        theta = (*mpND_theta);
        psi = (*mpND_psi);
        beta = (*mpND_beta);
        phimax = (*mpND_phimax);
        Rb = (*mpND_Rb);
        Ub = (*mpND_Ub);

        //LocalExpressions
        Kv = Power(mU0,2)/(Power(mU0,2) + Power(Abs(Ub),2));
        u1cmin = Kv*mu1min;
        u1cmax = Kv*mu1max;
        u2cmin = Kv*mu2min;
        u2cmax = Kv*mu2max;
        u3cmin = mu3min;
        u3cmax = mu3max;

          //Expressions
          uaerL = limit(Kv*mKphi*diffAngle(phiref + \
limit(mKphipsi*diffAngle(psiref,psi),-phimax,phimax),phi),u1cmin,u1cmax);
          uaerR = limit(-(Kv*mKphi*diffAngle(phiref + \
limit(mKphipsi*diffAngle(psiref,psi),-phimax,phimax),phi)),u1cmin,u1cmax);
          uelev = \
limit(-(Kv*mKelev*diffAngle(thetaref,theta)),u2cmin,u2cmax);
          urud = limit(beta*mKrud - Kv*mKRrud*Rb,u3cmin,u3cmax);

        //Calculate the delayed parts


        //Write new values to nodes
        //outputVariables
        (*mpND_uaerL)=uaerL;
        (*mpND_uaerR)=uaerR;
        (*mpND_uelev)=uelev;
        (*mpND_urud)=urud;

        //Update the delayed variabels

     }
};
#endif // SIGNALATTITUDECONTROL_HPP_INCLUDED
