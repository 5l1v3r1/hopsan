#ifndef SIGNALSTATEMONITOR_HPP_INCLUDED
#define SIGNALSTATEMONITOR_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file SignalStateMonitor.hpp
//! @author Petter Krus <petter.krus@liu.se>
//! @date Fri 24 Aug 2012 10:21:52
//! @brief Check for steady state
//! @ingroup SignalComponents
//!
//This component is generated by COMPGEN for HOPSAN-NG simulation 
//from 
/*{, C:, Documents and Settings, petkr14, My Documents, \
CompgenNG}/SignalControlAeroNG.nb*/

using namespace hopsan;

class SignalStateMonitor : public ComponentSignal
{
private:
     double my10;
     double my20;
     double my30;
     double mthau;
     double my1;
     double my2;
     double my3;
     double msOn;
     Port *mpPy1;
     Port *mpPy2;
     Port *mpPy3;
     Port *mpPsOn;
     Port *mpPs1;
     Port *mpPy1f;
     Port *mpPy2f;
     Port *mpPy3f;
     double delayParts1[9];
     double delayParts2[9];
     double delayParts3[9];
     double delayParts4[9];
     Matrix jacobianMatrix;
     Vec systemEquations;
     Matrix delayedPart;
     int i;
     int iter;
     int mNoiter;
     double jsyseqnweight[4];
     int order[4];
     int mNstep;
     //inputVariables
     double y1;
     double y2;
     double y3;
     double sOn;
     //outputVariables
     double s1;
     double y1f;
     double y2f;
     double y3f;
     //Delay declarations
     //inputVariables pointers
     double *mpND_y1;
     double *mpND_y2;
     double *mpND_y3;
     double *mpND_sOn;
     //outputVariables pointers
     double *mpND_s1;
     double *mpND_y1f;
     double *mpND_y2f;
     double *mpND_y3f;
     Delay mDelayedPart10;
     Delay mDelayedPart11;
     Delay mDelayedPart20;
     Delay mDelayedPart21;
     Delay mDelayedPart30;
     Delay mDelayedPart31;
     Delay mDelayedPart40;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new SignalStateMonitor();
     }

     void configure()
     {
        const double y10 = 0.02;
        const double y20 = 0.02;
        const double y30 = 0.02;
        const double thau = 1.;
        const double y1 = 0.;
        const double y2 = 0.;
        const double y3 = 0.;
        const double sOn = 0.;

        mNstep=9;
        jacobianMatrix.create(4,4);
        systemEquations.create(4);
        delayedPart.create(5,6);
        mNoiter=2;
        jsyseqnweight[0]=1;
        jsyseqnweight[1]=0.67;
        jsyseqnweight[2]=0.5;
        jsyseqnweight[3]=0.5;

        my10 = y10;
        my20 = y20;
        my30 = y30;
        mthau = thau;
        my1 = y1;
        my2 = y2;
        my3 = y3;
        msOn = sOn;

        //Add ports to the component

        //Add inputVariables ports to the component
        mpPy1=addReadPort("Py1","NodeSignal", Port::NOTREQUIRED);
        mpPy2=addReadPort("Py2","NodeSignal", Port::NOTREQUIRED);
        mpPy3=addReadPort("Py3","NodeSignal", Port::NOTREQUIRED);
        mpPsOn=addReadPort("PsOn","NodeSignal", Port::NOTREQUIRED);

        //Add outputVariables ports to the component
        mpPs1=addWritePort("Ps1","NodeSignal", Port::NOTREQUIRED);
        mpPy1f=addWritePort("Py1f","NodeSignal", Port::NOTREQUIRED);
        mpPy2f=addWritePort("Py2f","NodeSignal", Port::NOTREQUIRED);
        mpPy3f=addWritePort("Py3f","NodeSignal", Port::NOTREQUIRED);

        //Register changable parameters to the HOPSAN++ core
        registerParameter("y10", "treashold variable 1", "", my10);
        registerParameter("y20", "treashold variable 2", "", my20);
        registerParameter("y30", "treashold variable 3", "", my30);
        registerParameter("thau", "filter time constant 2", "sec", mthau);
        registerParameter("y1", "monitored variable 1", "", my1);
        registerParameter("y2", "monitored variable 2", "", my2);
        registerParameter("y3", "monitored variable 3", "", my3);
        registerParameter("sOn", "extra trigg signal", "", msOn);
        mpSolver = new EquationSystemSolver(this,4);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Read inputVariables pointers from nodes
        mpND_y1=getSafeNodeDataPtr(mpPy1, NodeSignal::VALUE,my1);
        mpND_y2=getSafeNodeDataPtr(mpPy2, NodeSignal::VALUE,my2);
        mpND_y3=getSafeNodeDataPtr(mpPy3, NodeSignal::VALUE,my3);
        mpND_sOn=getSafeNodeDataPtr(mpPsOn, NodeSignal::VALUE,msOn);
        //Read outputVariable pointers from nodes
        mpND_s1=getSafeNodeDataPtr(mpPs1, NodeSignal::VALUE);
        mpND_y1f=getSafeNodeDataPtr(mpPy1f, NodeSignal::VALUE);
        mpND_y2f=getSafeNodeDataPtr(mpPy2f, NodeSignal::VALUE);
        mpND_y3f=getSafeNodeDataPtr(mpPy3f, NodeSignal::VALUE);

        //Read variables from nodes

        //Read inputVariables from nodes
        y1 = (*mpND_y1);
        y2 = (*mpND_y2);
        y3 = (*mpND_y3);
        sOn = (*mpND_sOn);

        //Read outputVariables from nodes
        s1 = mpPs1->getStartValue(NodeSignal::VALUE);
        y1f = mpPy1f->getStartValue(NodeSignal::VALUE);
        y2f = mpPy2f->getStartValue(NodeSignal::VALUE);
        y3f = mpPy3f->getStartValue(NodeSignal::VALUE);



        //Initialize delays
        delayParts1[1] = (-2*mthau*y1f + mTimestep*y1f - \
mTimestep*Abs(y1))/(2*mthau + mTimestep);
        mDelayedPart11.initialize(mNstep,delayParts1[1]);
        delayParts2[1] = (-2*mthau*y2f + mTimestep*y2f - \
mTimestep*Abs(y2))/(2*mthau + mTimestep);
        mDelayedPart21.initialize(mNstep,delayParts2[1]);
        delayParts3[1] = (-2*mthau*y3f + mTimestep*y3f - \
mTimestep*Abs(y3))/(2*mthau + mTimestep);
        mDelayedPart31.initialize(mNstep,delayParts3[1]);

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
     }
    void simulateOneTimestep()
     {
        Vec stateVar(4);
        Vec stateVark(4);
        Vec deltaStateVar(4);

        //Read variables from nodes

        //Read inputVariables from nodes
        y1 = (*mpND_y1);
        y2 = (*mpND_y2);
        y3 = (*mpND_y3);
        sOn = (*mpND_sOn);

        //LocalExpressions

        //Initializing variable vector for Newton-Raphson
        stateVark[0] = y1f;
        stateVark[1] = y2f;
        stateVark[2] = y3f;
        stateVark[3] = s1;

        //Iterative solution using Newton-Rapshson
        for(iter=1;iter<=mNoiter;iter++)
        {
         //StateMonitor
         //Differential-algebraic system of equation parts

          //Assemble differential-algebraic equations
          systemEquations[0] =y1f - (mTimestep*Abs(y1))/(2*mthau + mTimestep) \
+ delayedPart[1][1];
          systemEquations[1] =y2f - (mTimestep*Abs(y2))/(2*mthau + mTimestep) \
+ delayedPart[2][1];
          systemEquations[2] =y3f - (mTimestep*Abs(y3))/(2*mthau + mTimestep) \
+ delayedPart[3][1];
          systemEquations[3] =s1 - onPositive(-0.5 + sOn + \
onPositive(-Abs(my10) + Abs(y1f)) + onPositive(-Abs(my20) + Abs(y2f)) + \
onPositive(-Abs(my30) + Abs(y3f)));

          //Jacobian matrix
          jacobianMatrix[0][0] = 1;
          jacobianMatrix[0][1] = 0;
          jacobianMatrix[0][2] = 0;
          jacobianMatrix[0][3] = 0;
          jacobianMatrix[1][0] = 0;
          jacobianMatrix[1][1] = 1;
          jacobianMatrix[1][2] = 0;
          jacobianMatrix[1][3] = 0;
          jacobianMatrix[2][0] = 0;
          jacobianMatrix[2][1] = 0;
          jacobianMatrix[2][2] = 1;
          jacobianMatrix[2][3] = 0;
          jacobianMatrix[3][0] = 0;
          jacobianMatrix[3][1] = 0;
          jacobianMatrix[3][2] = 0;
          jacobianMatrix[3][3] = 1;

          //Solving equation using LU-faktorisation
          mpSolver->solve(jacobianMatrix, systemEquations, stateVark, iter);
          y1f=stateVark[0];
          y2f=stateVark[1];
          y3f=stateVark[2];
          s1=stateVark[3];
        }

        //Calculate the delayed parts
        delayParts1[1] = (-2*mthau*y1f + mTimestep*y1f - \
mTimestep*Abs(y1))/(2*mthau + mTimestep);
        delayParts2[1] = (-2*mthau*y2f + mTimestep*y2f - \
mTimestep*Abs(y2))/(2*mthau + mTimestep);
        delayParts3[1] = (-2*mthau*y3f + mTimestep*y3f - \
mTimestep*Abs(y3))/(2*mthau + mTimestep);

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];

        //Write new values to nodes
        //outputVariables
        (*mpND_s1)=s1;
        (*mpND_y1f)=y1f;
        (*mpND_y2f)=y2f;
        (*mpND_y3f)=y3f;

        //Update the delayed variabels
        mDelayedPart11.update(delayParts1[1]);
        mDelayedPart21.update(delayParts2[1]);
        mDelayedPart31.update(delayParts3[1]);

     }
};
#endif // SIGNALSTATEMONITOR_HPP_INCLUDED
