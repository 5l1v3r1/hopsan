#ifndef SIGNALFFBLOOP_HPP_INCLUDED
#define SIGNALFFBLOOP_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file SignalFFBloop.hpp
//! @author Petter Krus <petter.krus@liu.se>
//! @date Fri 24 Aug 2012 10:28:19
//! @brief FFBD loop out
//! @ingroup SignalComponents
//!
//This component is generated by COMPGEN for HOPSAN-NG simulation 
//from 
/*{, C:, Documents and Settings, petkr14, My Documents, \
CompgenNG}/FFBDcomponentsNG.nb*/

using namespace hopsan;

class SignalFFBloop : public ComponentSignal
{
private:
     double min0;
     double mdivert;
     Port *mpPin0;
     Port *mpPdivert;
     Port *mpPstate;
     Port *mpPout0;
     Port *mpPout1;
     int mNstep;
     //inputVariables
     double in0;
     double divert;
     //outputVariables
     double state;
     double out0;
     double out1;
     //Expressions variables
     double oldState;
     double oldIn0;
     double oldOut0;
     double oldOut1;
     //Delay declarations
     //inputVariables pointers
     double *mpND_in0;
     double *mpND_divert;
     //outputVariables pointers
     double *mpND_state;
     double *mpND_out0;
     double *mpND_out1;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new SignalFFBloop();
     }

     void configure()
     {
        const double in0 = 0.;
        const double divert = 0.;

        mNstep=9;
        min0 = in0;
        mdivert = divert;

        //Add ports to the component

        //Add inputVariables ports to the component
        mpPin0=addReadPort("Pin0","NodeSignal", Port::NotRequired);
        mpPdivert=addReadPort("Pdivert","NodeSignal", Port::NotRequired);

        //Add outputVariables ports to the component
        mpPstate=addWritePort("Pstate","NodeSignal", Port::NotRequired);
        mpPout0=addWritePort("Pout0","NodeSignal", Port::NotRequired);
        mpPout1=addWritePort("Pout1","NodeSignal", Port::NotRequired);

        //Register changable parameters to the HOPSAN++ core
        registerParameter("in0", "Input 0", "", min0);
        registerParameter("divert", "Input 0", "", mdivert);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Read inputVariables pointers from nodes
        mpND_in0=getSafeNodeDataPtr(mpPin0, NodeSignal::Value,min0);
        mpND_divert=getSafeNodeDataPtr(mpPdivert, NodeSignal::Value,mdivert);
        //Read outputVariable pointers from nodes
        mpND_state=getSafeNodeDataPtr(mpPstate, NodeSignal::Value);
        mpND_out0=getSafeNodeDataPtr(mpPout0, NodeSignal::Value);
        mpND_out1=getSafeNodeDataPtr(mpPout1, NodeSignal::Value);

        //Read variables from nodes

        //Read inputVariables from nodes
        in0 = (*mpND_in0);
        divert = (*mpND_divert);

        //Read outputVariables from nodes
        state = mpPstate->getStartValue(NodeSignal::Value);
        out0 = mpPout0->getStartValue(NodeSignal::Value);
        out1 = mpPout1->getStartValue(NodeSignal::Value);

        //InitialExpressions
        oldState = state;
        oldIn0 = in0;
        oldOut0 = out0;
        oldOut1 = out1;


        //Initialize delays

     }
    void simulateOneTimestep()
     {
        //Read variables from nodes

        //Read inputVariables from nodes
        in0 = (*mpND_in0);
        divert = (*mpND_divert);

        //LocalExpressions

          //Expressions
          state = onPositive(-0.5 + 2*onPositive(-0.5 + in0 - oldIn0) - \
onPositive(-0.5 + oldOut0 + oldOut1) + onPositive(-0.5 + oldState));
          out0 = state*onPositive(0.5 - divert);
          out1 = state*onPositive(-0.5 + divert);
          oldState = state;
          oldIn0 = in0;
          oldOut0 = out0;
          oldOut1 = out1;

        //Calculate the delayed parts


        //Write new values to nodes
        //outputVariables
        (*mpND_state)=state;
        (*mpND_out0)=out0;
        (*mpND_out1)=out1;

        //Update the delayed variabels

     }
};
#endif // SIGNALFFBLOOP_HPP_INCLUDED
