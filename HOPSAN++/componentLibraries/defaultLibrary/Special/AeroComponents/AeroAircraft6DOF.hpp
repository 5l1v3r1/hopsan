#ifndef AEROAIRCRAFT6DOF_HPP_INCLUDED
#define AEROAIRCRAFT6DOF_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file AeroAircraft6DOF.hpp
//! @author Petter Krus <petter.krus@liu.se>
//! @date Thu 6 Sep 2012 08:29:22
//! @brief Flight dynamics model of aircraft
//! @ingroup AeroComponents
//!
//This component is generated by COMPGEN for HOPSAN-NG simulation 
//from 
/*{, C:, Documents and Settings, petkr14, My Documents, \
CompgenNG}/AeroAircraft1.nb*/

using namespace hopsan;

class AeroAircraft6DOF : public ComponentC
{
private:
     double mafin;
     double man1;
     double man2;
     double map1;
     double map2;
     double mAR1;
     double mAR2;
     double mARfin;
     double mCd01;
     double mCd02;
     double mCd0b;
     double mCd0fin;
     double mCLalpha1;
     double mCLalpha2;
     double mCLalphabh;
     double mCLalphabv;
     double mCLalphafin;
     double mCLde1;
     double mCLde2;
     double mCLde12;
     double mCdide1;
     double mCdide12;
     double mCdide112;
     double mde10;
     double mde120;
     double mCm01;
     double mCmfs1;
     double mCmde1;
     double mCmde12;
     double mCLdefin;
     double mdah1;
     double mdah2;
     double me1;
     double me2;
     double mefin;
     double mawfin;
     double mawn1;
     double mawn2;
     double mawp1;
     double mawp2;
     double mgamma1;
     double mgamma2;
     double mhthrust;
     double mia1;
     double mia2;
     double mIx;
     double mIxz;
     double mIy;
     double mIz;
     double mlambda1;
     double mlambda2;
     double mlambdafin;
     double mlc1;
     double mlc2;
     double mlc12;
     double mlcfin;
     double mMe;
     double mrc1;
     double mrc2;
     double mrcfin;
     double mS1;
     double mS2;
     double mSbh;
     double mSbv;
     double mSfin;
     double mxbach;
     double mxbacv;
     double mxbcge;
     double mxcargo;
     double mxfuel;
     double mxw1;
     double mxw2;
     double mxwfin;
     double myeng;
     double mg0;
     double mkground;
     double mcground;
     double mthrustl;
     double mthrustr;
     double mdezthrust;
     double mMfuel;
     double mMcargo;
     double mrho;
     double mvturbx;
     double mvturby;
     double mvturbz;
     double mwturbx;
     double mwturby;
     double mwturbz;
     Port *mpPal1;
     Port *mpPar1;
     Port *mpPal12;
     Port *mpPar12;
     Port *mpPal2;
     Port *mpPar2;
     Port *mpPfin;
     Port *mpPthrustl;
     Port *mpPthrustr;
     Port *mpPdezthrust;
     Port *mpPMfuel;
     Port *mpPMcargo;
     Port *mpPrho;
     Port *mpPvturbx;
     Port *mpPvturby;
     Port *mpPvturbz;
     Port *mpPwturbx;
     Port *mpPwturby;
     Port *mpPwturbz;
     Port *mpPxcg;
     Port *mpPycg;
     Port *mpPzcg;
     Port *mpPvx;
     Port *mpPvy;
     Port *mpPvz;
     Port *mpPPsi;
     Port *mpPThetao;
     Port *mpPPhi;
     Port *mpPUb;
     Port *mpPVb;
     Port *mpPWb;
     Port *mpPPb;
     Port *mpPQb;
     Port *mpPRb;
     Port *mpPq0;
     Port *mpPq1;
     Port *mpPq2;
     Port *mpPq3;
     Port *mpPAlphaAttack;
     Port *mpPBetaSlip;
     Port *mpPaltitude;
     Port *mpPgfx;
     Port *mpPgfy;
     Port *mpPgfz;
     Port *mpPCL1;
     Port *mpPCd1;
     Port *mpPFax;
     Port *mpPFaz;
     double delayParts1[9];
     double delayParts2[9];
     double delayParts3[9];
     double delayParts4[9];
     double delayParts5[9];
     double delayParts6[9];
     double delayParts7[9];
     double delayParts8[9];
     double delayParts9[9];
     double delayParts10[9];
     double delayParts11[9];
     double delayParts12[9];
     double delayParts13[9];
     Matrix jacobianMatrix;
     Vec systemEquations;
     Matrix delayedPart;
     int i;
     int iter;
     int mNoiter;
     double jsyseqnweight[4];
     int order[13];
     int mNstep;
     //Port Pal1 variable
     double toral1;
     double thetaal1;
     double wal1;
     double cal1;
     double Zcal1;
     double eqInertiaal1;
     //Port Par1 variable
     double torar1;
     double thetaar1;
     double war1;
     double car1;
     double Zcar1;
     double eqInertiaar1;
     //Port Pal12 variable
     double toral12;
     double thetaal12;
     double wal12;
     double cal12;
     double Zcal12;
     double eqInertiaal12;
     //Port Par12 variable
     double torar12;
     double thetaar12;
     double war12;
     double car12;
     double Zcar12;
     double eqInertiaar12;
     //Port Pal2 variable
     double toral2;
     double thetaal2;
     double wal2;
     double cal2;
     double Zcal2;
     double eqInertiaal2;
     //Port Par2 variable
     double torar2;
     double thetaar2;
     double war2;
     double car2;
     double Zcar2;
     double eqInertiaar2;
     //Port Pfin variable
     double torfin;
     double thetafin;
     double wfin;
     double cfin;
     double Zcfin;
     double eqInertiafin;
     //inputVariables
     double thrustl;
     double thrustr;
     double dezthrust;
     double Mfuel;
     double Mcargo;
     double rho;
     double vturbx;
     double vturby;
     double vturbz;
     double wturbx;
     double wturby;
     double wturbz;
     //outputVariables
     double xcg;
     double ycg;
     double zcg;
     double vx;
     double vy;
     double vz;
     double Psi;
     double Thetao;
     double Phi;
     double Ub;
     double Vb;
     double Wb;
     double Pb;
     double Qb;
     double Rb;
     double q0;
     double q1;
     double q2;
     double q3;
     double AlphaAttack;
     double BetaSlip;
     double altitude;
     double gfx;
     double gfy;
     double gfz;
     double CL1;
     double Cd1;
     double Fax;
     double Faz;
     //LocalExpressions variables
     double v;
     double Alpha;
     double qpress;
     double Beta;
     double mass;
     double xbcg;
     double Dragl1;
     double Dragr1;
     double Liftl1;
     double Liftr1;
     double Dragl2;
     double Dragr2;
     double Liftl2;
     double Liftr2;
     double Liftb;
     double Dragb;
     double Cfin;
     double Dragfin;
     double Mdvtheta;
     double Mdvpsi;
     double Fx;
     double Fy;
     double Fz;
     double Lb;
     double Mb;
     double Nb;
     //Expressions variables
     //Port Pal1 pointer
     double *mpND_toral1;
     double *mpND_thetaal1;
     double *mpND_wal1;
     double *mpND_cal1;
     double *mpND_Zcal1;
     double *mpND_eqInertiaal1;
     //Port Par1 pointer
     double *mpND_torar1;
     double *mpND_thetaar1;
     double *mpND_war1;
     double *mpND_car1;
     double *mpND_Zcar1;
     double *mpND_eqInertiaar1;
     //Port Pal12 pointer
     double *mpND_toral12;
     double *mpND_thetaal12;
     double *mpND_wal12;
     double *mpND_cal12;
     double *mpND_Zcal12;
     double *mpND_eqInertiaal12;
     //Port Par12 pointer
     double *mpND_torar12;
     double *mpND_thetaar12;
     double *mpND_war12;
     double *mpND_car12;
     double *mpND_Zcar12;
     double *mpND_eqInertiaar12;
     //Port Pal2 pointer
     double *mpND_toral2;
     double *mpND_thetaal2;
     double *mpND_wal2;
     double *mpND_cal2;
     double *mpND_Zcal2;
     double *mpND_eqInertiaal2;
     //Port Par2 pointer
     double *mpND_torar2;
     double *mpND_thetaar2;
     double *mpND_war2;
     double *mpND_car2;
     double *mpND_Zcar2;
     double *mpND_eqInertiaar2;
     //Port Pfin pointer
     double *mpND_torfin;
     double *mpND_thetafin;
     double *mpND_wfin;
     double *mpND_cfin;
     double *mpND_Zcfin;
     double *mpND_eqInertiafin;
     //Delay declarations
     //inputVariables pointers
     double *mpND_thrustl;
     double *mpND_thrustr;
     double *mpND_dezthrust;
     double *mpND_Mfuel;
     double *mpND_Mcargo;
     double *mpND_rho;
     double *mpND_vturbx;
     double *mpND_vturby;
     double *mpND_vturbz;
     double *mpND_wturbx;
     double *mpND_wturby;
     double *mpND_wturbz;
     //outputVariables pointers
     double *mpND_xcg;
     double *mpND_ycg;
     double *mpND_zcg;
     double *mpND_vx;
     double *mpND_vy;
     double *mpND_vz;
     double *mpND_Psi;
     double *mpND_Thetao;
     double *mpND_Phi;
     double *mpND_Ub;
     double *mpND_Vb;
     double *mpND_Wb;
     double *mpND_Pb;
     double *mpND_Qb;
     double *mpND_Rb;
     double *mpND_q0;
     double *mpND_q1;
     double *mpND_q2;
     double *mpND_q3;
     double *mpND_AlphaAttack;
     double *mpND_BetaSlip;
     double *mpND_altitude;
     double *mpND_gfx;
     double *mpND_gfy;
     double *mpND_gfz;
     double *mpND_CL1;
     double *mpND_Cd1;
     double *mpND_Fax;
     double *mpND_Faz;
     Delay mDelayedPart10;
     Delay mDelayedPart11;
     Delay mDelayedPart20;
     Delay mDelayedPart21;
     Delay mDelayedPart30;
     Delay mDelayedPart31;
     Delay mDelayedPart40;
     Delay mDelayedPart41;
     Delay mDelayedPart50;
     Delay mDelayedPart51;
     Delay mDelayedPart60;
     Delay mDelayedPart61;
     Delay mDelayedPart70;
     Delay mDelayedPart71;
     Delay mDelayedPart80;
     Delay mDelayedPart81;
     Delay mDelayedPart90;
     Delay mDelayedPart91;
     Delay mDelayedPart100;
     Delay mDelayedPart101;
     Delay mDelayedPart110;
     Delay mDelayedPart111;
     Delay mDelayedPart120;
     Delay mDelayedPart121;
     Delay mDelayedPart130;
     Delay mDelayedPart131;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new AeroAircraft6DOF();
     }

     void configure()
     {
        const double afin = 0.3;
        const double an1 = 0.6;
        const double an2 = 0.6;
        const double ap1 = 0.9;
        const double ap2 = 0.7;
        const double AR1 = 2.24;
        const double AR2 = 2.2;
        const double ARfin = 0.58;
        const double Cd01 = 0.0045;
        const double Cd02 = 0.0045;
        const double Cd0b = 0.004;
        const double Cd0fin = 0.0045;
        const double CLalpha1 = 2.1;
        const double CLalpha2 = 2.2;
        const double CLalphabh = 2.;
        const double CLalphabv = 2.;
        const double CLalphafin = 0.8;
        const double CLde1 = 0.1;
        const double CLde2 = 0.515;
        const double CLde12 = 0.2;
        const double Cdide1 = 0.;
        const double Cdide12 = 0.;
        const double Cdide112 = 0.;
        const double de10 = 0.01;
        const double de120 = 0.01;
        const double Cm01 = -0.1;
        const double Cmfs1 = -0.5;
        const double Cmde1 = 0.02;
        const double Cmde12 = 0.1;
        const double CLdefin = 0.0827084;
        const double dah1 = 1.;
        const double dah2 = 0.6;
        const double e1 = 0.95;
        const double e2 = 0.95;
        const double efin = 0.95;
        const double awfin = 0.2;
        const double awn1 = 0.2;
        const double awn2 = 0.2;
        const double awp1 = 0.2;
        const double awp2 = 0.2;
        const double gamma1 = -0.0872665;
        const double gamma2 = -0.0872665;
        const double hthrust = 0.;
        const double ia1 = 0.;
        const double ia2 = 0.02;
        const double Ix = 1000.;
        const double Ixz = 500.;
        const double Iy = 3000.;
        const double Iz = 3000.;
        const double lambda1 = 0.436332;
        const double lambda2 = 0.436332;
        const double lambdafin = 0.785398;
        const double lc1 = 0.1;
        const double lc2 = 0.1;
        const double lc12 = 0.1;
        const double lcfin = 0.1;
        const double Me = 5000.;
        const double rc1 = 2.5;
        const double rc2 = 1.5;
        const double rcfin = 1.;
        const double S1 = 40.;
        const double S2 = 20.;
        const double Sbh = 0.1;
        const double Sbv = 0.1;
        const double Sfin = 6.94;
        const double xbach = 8.5;
        const double xbacv = 8.5;
        const double xbcge = 6.;
        const double xcargo = 6.;
        const double xfuel = 6.;
        const double xw1 = 5;
        const double xw2 = 11;
        const double xwfin = 10;
        const double yeng = 0.;
        const double g0 = 9.81;
        const double kground = 10000.;
        const double cground = 1000.;
        const double thrustl = 0.;
        const double thrustr = 0.;
        const double dezthrust = 0.;
        const double Mfuel = 0.;
        const double Mcargo = 0.;
        const double rho = 1.25;
        const double vturbx = 0.;
        const double vturby = 0.;
        const double vturbz = 0.;
        const double wturbx = 0.;
        const double wturby = 0.;
        const double wturbz = 0.;

        mNstep=9;
        jacobianMatrix.create(13,13);
        systemEquations.create(13);
        delayedPart.create(14,6);
        mNoiter=2;
        jsyseqnweight[0]=1;
        jsyseqnweight[1]=0.67;
        jsyseqnweight[2]=0.5;
        jsyseqnweight[3]=0.5;

        mafin = afin;
        man1 = an1;
        man2 = an2;
        map1 = ap1;
        map2 = ap2;
        mAR1 = AR1;
        mAR2 = AR2;
        mARfin = ARfin;
        mCd01 = Cd01;
        mCd02 = Cd02;
        mCd0b = Cd0b;
        mCd0fin = Cd0fin;
        mCLalpha1 = CLalpha1;
        mCLalpha2 = CLalpha2;
        mCLalphabh = CLalphabh;
        mCLalphabv = CLalphabv;
        mCLalphafin = CLalphafin;
        mCLde1 = CLde1;
        mCLde2 = CLde2;
        mCLde12 = CLde12;
        mCdide1 = Cdide1;
        mCdide12 = Cdide12;
        mCdide112 = Cdide112;
        mde10 = de10;
        mde120 = de120;
        mCm01 = Cm01;
        mCmfs1 = Cmfs1;
        mCmde1 = Cmde1;
        mCmde12 = Cmde12;
        mCLdefin = CLdefin;
        mdah1 = dah1;
        mdah2 = dah2;
        me1 = e1;
        me2 = e2;
        mefin = efin;
        mawfin = awfin;
        mawn1 = awn1;
        mawn2 = awn2;
        mawp1 = awp1;
        mawp2 = awp2;
        mgamma1 = gamma1;
        mgamma2 = gamma2;
        mhthrust = hthrust;
        mia1 = ia1;
        mia2 = ia2;
        mIx = Ix;
        mIxz = Ixz;
        mIy = Iy;
        mIz = Iz;
        mlambda1 = lambda1;
        mlambda2 = lambda2;
        mlambdafin = lambdafin;
        mlc1 = lc1;
        mlc2 = lc2;
        mlc12 = lc12;
        mlcfin = lcfin;
        mMe = Me;
        mrc1 = rc1;
        mrc2 = rc2;
        mrcfin = rcfin;
        mS1 = S1;
        mS2 = S2;
        mSbh = Sbh;
        mSbv = Sbv;
        mSfin = Sfin;
        mxbach = xbach;
        mxbacv = xbacv;
        mxbcge = xbcge;
        mxcargo = xcargo;
        mxfuel = xfuel;
        mxw1 = xw1;
        mxw2 = xw2;
        mxwfin = xwfin;
        myeng = yeng;
        mg0 = g0;
        mkground = kground;
        mcground = cground;
        mthrustl = thrustl;
        mthrustr = thrustr;
        mdezthrust = dezthrust;
        mMfuel = Mfuel;
        mMcargo = Mcargo;
        mrho = rho;
        mvturbx = vturbx;
        mvturby = vturby;
        mvturbz = vturbz;
        mwturbx = wturbx;
        mwturby = wturby;
        mwturbz = wturbz;

        //Add ports to the component
        mpPal1=addPowerPort("Pal1","NodeMechanicRotational");
        mpPar1=addPowerPort("Par1","NodeMechanicRotational");
        mpPal12=addPowerPort("Pal12","NodeMechanicRotational");
        mpPar12=addPowerPort("Par12","NodeMechanicRotational");
        mpPal2=addPowerPort("Pal2","NodeMechanicRotational");
        mpPar2=addPowerPort("Par2","NodeMechanicRotational");
        mpPfin=addPowerPort("Pfin","NodeMechanicRotational");

        //Add inputVariables ports to the component
        mpPthrustl=addReadPort("Pthrustl","NodeSignal", Port::NotRequired);
        mpPthrustr=addReadPort("Pthrustr","NodeSignal", Port::NotRequired);
        mpPdezthrust=addReadPort("Pdezthrust","NodeSignal", \
Port::NotRequired);
        mpPMfuel=addReadPort("PMfuel","NodeSignal", Port::NotRequired);
        mpPMcargo=addReadPort("PMcargo","NodeSignal", Port::NotRequired);
        mpPrho=addReadPort("Prho","NodeSignal", Port::NotRequired);
        mpPvturbx=addReadPort("Pvturbx","NodeSignal", Port::NotRequired);
        mpPvturby=addReadPort("Pvturby","NodeSignal", Port::NotRequired);
        mpPvturbz=addReadPort("Pvturbz","NodeSignal", Port::NotRequired);
        mpPwturbx=addReadPort("Pwturbx","NodeSignal", Port::NotRequired);
        mpPwturby=addReadPort("Pwturby","NodeSignal", Port::NotRequired);
        mpPwturbz=addReadPort("Pwturbz","NodeSignal", Port::NotRequired);

        //Add outputVariables ports to the component
        mpPxcg=addWritePort("Pxcg","NodeSignal", Port::NotRequired);
        mpPycg=addWritePort("Pycg","NodeSignal", Port::NotRequired);
        mpPzcg=addWritePort("Pzcg","NodeSignal", Port::NotRequired);
        mpPvx=addWritePort("Pvx","NodeSignal", Port::NotRequired);
        mpPvy=addWritePort("Pvy","NodeSignal", Port::NotRequired);
        mpPvz=addWritePort("Pvz","NodeSignal", Port::NotRequired);
        mpPPsi=addWritePort("PPsi","NodeSignal", Port::NotRequired);
        mpPThetao=addWritePort("PThetao","NodeSignal", Port::NotRequired);
        mpPPhi=addWritePort("PPhi","NodeSignal", Port::NotRequired);
        mpPUb=addWritePort("PUb","NodeSignal", Port::NotRequired);
        mpPVb=addWritePort("PVb","NodeSignal", Port::NotRequired);
        mpPWb=addWritePort("PWb","NodeSignal", Port::NotRequired);
        mpPPb=addWritePort("PPb","NodeSignal", Port::NotRequired);
        mpPQb=addWritePort("PQb","NodeSignal", Port::NotRequired);
        mpPRb=addWritePort("PRb","NodeSignal", Port::NotRequired);
        mpPq0=addWritePort("Pq0","NodeSignal", Port::NotRequired);
        mpPq1=addWritePort("Pq1","NodeSignal", Port::NotRequired);
        mpPq2=addWritePort("Pq2","NodeSignal", Port::NotRequired);
        mpPq3=addWritePort("Pq3","NodeSignal", Port::NotRequired);
        mpPAlphaAttack=addWritePort("PAlphaAttack","NodeSignal", \
Port::NotRequired);
        mpPBetaSlip=addWritePort("PBetaSlip","NodeSignal", \
Port::NotRequired);
        mpPaltitude=addWritePort("Paltitude","NodeSignal", \
Port::NotRequired);
        mpPgfx=addWritePort("Pgfx","NodeSignal", Port::NotRequired);
        mpPgfy=addWritePort("Pgfy","NodeSignal", Port::NotRequired);
        mpPgfz=addWritePort("Pgfz","NodeSignal", Port::NotRequired);
        mpPCL1=addWritePort("PCL1","NodeSignal", Port::NotRequired);
        mpPCd1=addWritePort("PCd1","NodeSignal", Port::NotRequired);
        mpPFax=addWritePort("PFax","NodeSignal", Port::NotRequired);
        mpPFaz=addWritePort("PFaz","NodeSignal", Port::NotRequired);

        //Register changable parameters to the HOPSAN++ core
        registerParameter("afin", "comment", "rad", mafin);
        registerParameter("an1", "Neg. break angle 1", "rad", man1);
        registerParameter("an2", "Neg. break angle 2", "rad", man2);
        registerParameter("ap1", "Pos. break angle 1", "rad", map1);
        registerParameter("ap2", "Pos. break angle 2", "rad", map2);
        registerParameter("AR1", "Aspect ratio 1", "", mAR1);
        registerParameter("AR2", "Aspect rati 2o", "", mAR2);
        registerParameter("ARfin", "Aspect ratio fin", "", mARfin);
        registerParameter("Cd01", "Drag coef. 1", "", mCd01);
        registerParameter("Cd02", "Drag coef. 2", "", mCd02);
        registerParameter("Cd0b", "Drag coef. body", "", mCd0b);
        registerParameter("Cd0fin", "Drag coef. fin", "", mCd0fin);
        registerParameter("CLalpha1", "L. slope coef. 1", "", mCLalpha1);
        registerParameter("CLalpha2", "L. slope coef. 2", "", mCLalpha2);
        registerParameter("CLalphabh", "L. slope c. body h", "", mCLalphabh);
        registerParameter("CLalphabv", "L. slope c. bodyv", "", mCLalphabv);
        registerParameter("CLalphafin", "L. sl. c. fin", "", mCLalphafin);
        registerParameter("CLde1", "Ctrl surface coef 1", "", mCLde1);
        registerParameter("CLde2", "Ctrl surface coef 1", "", mCLde2);
        registerParameter("CLde12", "Flap rudder coef 1", "", mCLde12);
        registerParameter("Cdide1", "Flap rudder drag coef 1", "", mCdide1);
        registerParameter("Cdide12", "Flap rudder drag coef 1", "", \
mCdide12);
        registerParameter("Cdide112", "Flap rudder cross drag coef 1", "", \
mCdide112);
        registerParameter("de10", "rudder min drag angle 1", "", mde10);
        registerParameter("de120", "Flap min drag angle 1", "", mde120);
        registerParameter("Cm01", "Mom coeff. wing 1", "", mCm01);
        registerParameter("Cmfs1", "Mom coeff.1, fully separated", "", \
mCmfs1);
        registerParameter("Cmde1", "Mom slop coeff 1", "", mCmde1);
        registerParameter("Cmde12", "Flap Mom slop coeff 1", "", mCmde12);
        registerParameter("CLdefin", "Rudder coef 1", "", mCLdefin);
        registerParameter("dah1", "down wash effect on 1", "", mdah1);
        registerParameter("dah2", "down wash effect on 2", "", mdah2);
        registerParameter("e1", "Osw. effic. factor 1", "", me1);
        registerParameter("e2", "Osw. effic. factor 1", "", me2);
        registerParameter("efin", "Osw. eff. f. fin", "", mefin);
        registerParameter("awfin", "CL exponent fin", "", mawfin);
        registerParameter("awn1", "CL exponent neg. 1", "", mawn1);
        registerParameter("awn2", "CL exponent neg. 2", "", mawn2);
        registerParameter("awp1", "CL exponent pos 1", "", mawp1);
        registerParameter("awp2", "CL exponent neg 1", "", mawp2);
        registerParameter("gamma1", "dehidral", "rad", mgamma1);
        registerParameter("gamma2", "dehidral", "rad", mgamma2);
        registerParameter("hthrust", "engine vert. pos", "m", mhthrust);
        registerParameter("ia1", "incidence angle 1", "rad", mia1);
        registerParameter("ia2", "incidence angle 1", " rad", mia2);
        registerParameter("Ix", "Inertia moment", "kgm2", mIx);
        registerParameter("Ixz", "Inertia moment", "kgm2", mIxz);
        registerParameter("Iy", "Inertia moment", "kgm2", mIy);
        registerParameter("Iz", " Inertia moment", "kgm2", mIz);
        registerParameter("lambda1", "sweep 1", "rad", mlambda1);
        registerParameter("lambda2", "sweep 2", "rad", mlambda2);
        registerParameter("lambdafin", "sweep fin", "rad", mlambdafin);
        registerParameter("lc1", "ctrl surf. 1 ac fr hinge", "m", mlc1);
        registerParameter("lc2", "ctrl surf. 2 ac fr hinge", "m", mlc2);
        registerParameter("lc12", "flap 1 ac fr hinge", "m", mlc12);
        registerParameter("lcfin", "ctrl s. fin ac fr hinge", "m", mlcfin);
        registerParameter("Me", "Empty weight", "kg", mMe);
        registerParameter("rc1", "ctrl surface 1 mom. arm", "m", mrc1);
        registerParameter("rc2", "ctrl surface 1 mom. arm", "m", mrc2);
        registerParameter("rcfin", "ctrl surf. fin mom. arm", "m", mrcfin);
        registerParameter("S1", "wing area 1", "m2", mS1);
        registerParameter("S2", "wing area 2", "m2", mS2);
        registerParameter("Sbh", "body hor. proj. area", "m2", mSbh);
        registerParameter("Sbv", "body vert. proj. area", "m2", mSbv);
        registerParameter("Sfin", "fin area", "m2", mSfin);
        registerParameter("xbach", "body ac. hor.", "m", mxbach);
        registerParameter("xbacv", "body ac vert.", "m", mxbacv);
        registerParameter("xbcge", "body cg", "m", mxbcge);
        registerParameter("xcargo", "cargo pos.", "m", mxcargo);
        registerParameter("xfuel", "", "m", mxfuel);
        registerParameter("xw1", "", "m", mxw1);
        registerParameter("xw2", "", "m", mxw2);
        registerParameter("xwfin", "", "", mxwfin);
        registerParameter("yeng", "engines off. from center", "m", myeng);
        registerParameter("g0", "Gravity acceleration", "m/s^2", mg0);
        registerParameter("kground", "Ground stiffness (for limitiation)", \
"N/m", mkground);
        registerParameter("cground", "Ground damping (for limitiation)", \
"Ns/m", mcground);
        registerParameter("thrustl", "Engine thrust", "N", mthrustl);
        registerParameter("thrustr", "Engine thrust", "N", mthrustr);
        registerParameter("dezthrust", "Thrust angle", "rad", mdezthrust);
        registerParameter("Mfuel", "Fuel weight", "kg", mMfuel);
        registerParameter("Mcargo", "Cargo weight", "kg", mMcargo);
        registerParameter("rho", "Air density", "kg/m3", mrho);
        registerParameter("vturbx", "air turbulence x", "m/s", mvturbx);
        registerParameter("vturby", "air turbulence y", "m/s", mvturby);
        registerParameter("vturbz", "air turbulence z", "m/s", mvturbz);
        registerParameter("wturbx", "air turbulence x", "rad/s", mwturbx);
        registerParameter("wturby", "air turbulence y", "rad/s", mwturby);
        registerParameter("wturbz", "air turbulence z", "rad/s", mwturbz);
        mpSolver = new EquationSystemSolver(this,13);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Port Pal1
        mpND_toral1=getSafeNodeDataPtr(mpPal1, \
NodeMechanicRotational::Torque);
        mpND_thetaal1=getSafeNodeDataPtr(mpPal1, \
NodeMechanicRotational::Angle);
        mpND_wal1=getSafeNodeDataPtr(mpPal1, \
NodeMechanicRotational::AngularVelocity);
        mpND_cal1=getSafeNodeDataPtr(mpPal1, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcal1=getSafeNodeDataPtr(mpPal1, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiaal1=getSafeNodeDataPtr(mpPal1, \
NodeMechanicRotational::EquivalentInertia);
        //Port Par1
        mpND_torar1=getSafeNodeDataPtr(mpPar1, \
NodeMechanicRotational::Torque);
        mpND_thetaar1=getSafeNodeDataPtr(mpPar1, \
NodeMechanicRotational::Angle);
        mpND_war1=getSafeNodeDataPtr(mpPar1, \
NodeMechanicRotational::AngularVelocity);
        mpND_car1=getSafeNodeDataPtr(mpPar1, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcar1=getSafeNodeDataPtr(mpPar1, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiaar1=getSafeNodeDataPtr(mpPar1, \
NodeMechanicRotational::EquivalentInertia);
        //Port Pal12
        mpND_toral12=getSafeNodeDataPtr(mpPal12, \
NodeMechanicRotational::Torque);
        mpND_thetaal12=getSafeNodeDataPtr(mpPal12, \
NodeMechanicRotational::Angle);
        mpND_wal12=getSafeNodeDataPtr(mpPal12, \
NodeMechanicRotational::AngularVelocity);
        mpND_cal12=getSafeNodeDataPtr(mpPal12, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcal12=getSafeNodeDataPtr(mpPal12, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiaal12=getSafeNodeDataPtr(mpPal12, \
NodeMechanicRotational::EquivalentInertia);
        //Port Par12
        mpND_torar12=getSafeNodeDataPtr(mpPar12, \
NodeMechanicRotational::Torque);
        mpND_thetaar12=getSafeNodeDataPtr(mpPar12, \
NodeMechanicRotational::Angle);
        mpND_war12=getSafeNodeDataPtr(mpPar12, \
NodeMechanicRotational::AngularVelocity);
        mpND_car12=getSafeNodeDataPtr(mpPar12, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcar12=getSafeNodeDataPtr(mpPar12, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiaar12=getSafeNodeDataPtr(mpPar12, \
NodeMechanicRotational::EquivalentInertia);
        //Port Pal2
        mpND_toral2=getSafeNodeDataPtr(mpPal2, \
NodeMechanicRotational::Torque);
        mpND_thetaal2=getSafeNodeDataPtr(mpPal2, \
NodeMechanicRotational::Angle);
        mpND_wal2=getSafeNodeDataPtr(mpPal2, \
NodeMechanicRotational::AngularVelocity);
        mpND_cal2=getSafeNodeDataPtr(mpPal2, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcal2=getSafeNodeDataPtr(mpPal2, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiaal2=getSafeNodeDataPtr(mpPal2, \
NodeMechanicRotational::EquivalentInertia);
        //Port Par2
        mpND_torar2=getSafeNodeDataPtr(mpPar2, \
NodeMechanicRotational::Torque);
        mpND_thetaar2=getSafeNodeDataPtr(mpPar2, \
NodeMechanicRotational::Angle);
        mpND_war2=getSafeNodeDataPtr(mpPar2, \
NodeMechanicRotational::AngularVelocity);
        mpND_car2=getSafeNodeDataPtr(mpPar2, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcar2=getSafeNodeDataPtr(mpPar2, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiaar2=getSafeNodeDataPtr(mpPar2, \
NodeMechanicRotational::EquivalentInertia);
        //Port Pfin
        mpND_torfin=getSafeNodeDataPtr(mpPfin, \
NodeMechanicRotational::Torque);
        mpND_thetafin=getSafeNodeDataPtr(mpPfin, \
NodeMechanicRotational::Angle);
        mpND_wfin=getSafeNodeDataPtr(mpPfin, \
NodeMechanicRotational::AngularVelocity);
        mpND_cfin=getSafeNodeDataPtr(mpPfin, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcfin=getSafeNodeDataPtr(mpPfin, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiafin=getSafeNodeDataPtr(mpPfin, \
NodeMechanicRotational::EquivalentInertia);
        //Read inputVariables pointers from nodes
        mpND_thrustl=getSafeNodeDataPtr(mpPthrustl, \
NodeSignal::VALUE,mthrustl);
        mpND_thrustr=getSafeNodeDataPtr(mpPthrustr, \
NodeSignal::VALUE,mthrustr);
        mpND_dezthrust=getSafeNodeDataPtr(mpPdezthrust, \
NodeSignal::VALUE,mdezthrust);
        mpND_Mfuel=getSafeNodeDataPtr(mpPMfuel, NodeSignal::VALUE,mMfuel);
        mpND_Mcargo=getSafeNodeDataPtr(mpPMcargo, NodeSignal::VALUE,mMcargo);
        mpND_rho=getSafeNodeDataPtr(mpPrho, NodeSignal::VALUE,mrho);
        mpND_vturbx=getSafeNodeDataPtr(mpPvturbx, NodeSignal::VALUE,mvturbx);
        mpND_vturby=getSafeNodeDataPtr(mpPvturby, NodeSignal::VALUE,mvturby);
        mpND_vturbz=getSafeNodeDataPtr(mpPvturbz, NodeSignal::VALUE,mvturbz);
        mpND_wturbx=getSafeNodeDataPtr(mpPwturbx, NodeSignal::VALUE,mwturbx);
        mpND_wturby=getSafeNodeDataPtr(mpPwturby, NodeSignal::VALUE,mwturby);
        mpND_wturbz=getSafeNodeDataPtr(mpPwturbz, NodeSignal::VALUE,mwturbz);
        //Read outputVariable pointers from nodes
        mpND_xcg=getSafeNodeDataPtr(mpPxcg, NodeSignal::VALUE);
        mpND_ycg=getSafeNodeDataPtr(mpPycg, NodeSignal::VALUE);
        mpND_zcg=getSafeNodeDataPtr(mpPzcg, NodeSignal::VALUE);
        mpND_vx=getSafeNodeDataPtr(mpPvx, NodeSignal::VALUE);
        mpND_vy=getSafeNodeDataPtr(mpPvy, NodeSignal::VALUE);
        mpND_vz=getSafeNodeDataPtr(mpPvz, NodeSignal::VALUE);
        mpND_Psi=getSafeNodeDataPtr(mpPPsi, NodeSignal::VALUE);
        mpND_Thetao=getSafeNodeDataPtr(mpPThetao, NodeSignal::VALUE);
        mpND_Phi=getSafeNodeDataPtr(mpPPhi, NodeSignal::VALUE);
        mpND_Ub=getSafeNodeDataPtr(mpPUb, NodeSignal::VALUE);
        mpND_Vb=getSafeNodeDataPtr(mpPVb, NodeSignal::VALUE);
        mpND_Wb=getSafeNodeDataPtr(mpPWb, NodeSignal::VALUE);
        mpND_Pb=getSafeNodeDataPtr(mpPPb, NodeSignal::VALUE);
        mpND_Qb=getSafeNodeDataPtr(mpPQb, NodeSignal::VALUE);
        mpND_Rb=getSafeNodeDataPtr(mpPRb, NodeSignal::VALUE);
        mpND_q0=getSafeNodeDataPtr(mpPq0, NodeSignal::VALUE);
        mpND_q1=getSafeNodeDataPtr(mpPq1, NodeSignal::VALUE);
        mpND_q2=getSafeNodeDataPtr(mpPq2, NodeSignal::VALUE);
        mpND_q3=getSafeNodeDataPtr(mpPq3, NodeSignal::VALUE);
        mpND_AlphaAttack=getSafeNodeDataPtr(mpPAlphaAttack, \
NodeSignal::VALUE);
        mpND_BetaSlip=getSafeNodeDataPtr(mpPBetaSlip, NodeSignal::VALUE);
        mpND_altitude=getSafeNodeDataPtr(mpPaltitude, NodeSignal::VALUE);
        mpND_gfx=getSafeNodeDataPtr(mpPgfx, NodeSignal::VALUE);
        mpND_gfy=getSafeNodeDataPtr(mpPgfy, NodeSignal::VALUE);
        mpND_gfz=getSafeNodeDataPtr(mpPgfz, NodeSignal::VALUE);
        mpND_CL1=getSafeNodeDataPtr(mpPCL1, NodeSignal::VALUE);
        mpND_Cd1=getSafeNodeDataPtr(mpPCd1, NodeSignal::VALUE);
        mpND_Fax=getSafeNodeDataPtr(mpPFax, NodeSignal::VALUE);
        mpND_Faz=getSafeNodeDataPtr(mpPFaz, NodeSignal::VALUE);

        //Read variables from nodes
        //Port Pal1
        toral1 = (*mpND_toral1);
        thetaal1 = (*mpND_thetaal1);
        wal1 = (*mpND_wal1);
        cal1 = (*mpND_cal1);
        Zcal1 = (*mpND_Zcal1);
        eqInertiaal1 = (*mpND_eqInertiaal1);
        //Port Par1
        torar1 = (*mpND_torar1);
        thetaar1 = (*mpND_thetaar1);
        war1 = (*mpND_war1);
        car1 = (*mpND_car1);
        Zcar1 = (*mpND_Zcar1);
        eqInertiaar1 = (*mpND_eqInertiaar1);
        //Port Pal12
        toral12 = (*mpND_toral12);
        thetaal12 = (*mpND_thetaal12);
        wal12 = (*mpND_wal12);
        cal12 = (*mpND_cal12);
        Zcal12 = (*mpND_Zcal12);
        eqInertiaal12 = (*mpND_eqInertiaal12);
        //Port Par12
        torar12 = (*mpND_torar12);
        thetaar12 = (*mpND_thetaar12);
        war12 = (*mpND_war12);
        car12 = (*mpND_car12);
        Zcar12 = (*mpND_Zcar12);
        eqInertiaar12 = (*mpND_eqInertiaar12);
        //Port Pal2
        toral2 = (*mpND_toral2);
        thetaal2 = (*mpND_thetaal2);
        wal2 = (*mpND_wal2);
        cal2 = (*mpND_cal2);
        Zcal2 = (*mpND_Zcal2);
        eqInertiaal2 = (*mpND_eqInertiaal2);
        //Port Par2
        torar2 = (*mpND_torar2);
        thetaar2 = (*mpND_thetaar2);
        war2 = (*mpND_war2);
        car2 = (*mpND_car2);
        Zcar2 = (*mpND_Zcar2);
        eqInertiaar2 = (*mpND_eqInertiaar2);
        //Port Pfin
        torfin = (*mpND_torfin);
        thetafin = (*mpND_thetafin);
        wfin = (*mpND_wfin);
        cfin = (*mpND_cfin);
        Zcfin = (*mpND_Zcfin);
        eqInertiafin = (*mpND_eqInertiafin);

        //Read inputVariables from nodes
        thrustl = (*mpND_thrustl);
        thrustr = (*mpND_thrustr);
        dezthrust = (*mpND_dezthrust);
        Mfuel = (*mpND_Mfuel);
        Mcargo = (*mpND_Mcargo);
        rho = (*mpND_rho);
        vturbx = (*mpND_vturbx);
        vturby = (*mpND_vturby);
        vturbz = (*mpND_vturbz);
        wturbx = (*mpND_wturbx);
        wturby = (*mpND_wturby);
        wturbz = (*mpND_wturbz);

        //Read outputVariables from nodes
        xcg = mpPxcg->getStartValue(NodeSignal::VALUE);
        ycg = mpPycg->getStartValue(NodeSignal::VALUE);
        zcg = mpPzcg->getStartValue(NodeSignal::VALUE);
        vx = mpPvx->getStartValue(NodeSignal::VALUE);
        vy = mpPvy->getStartValue(NodeSignal::VALUE);
        vz = mpPvz->getStartValue(NodeSignal::VALUE);
        Psi = mpPPsi->getStartValue(NodeSignal::VALUE);
        Thetao = mpPThetao->getStartValue(NodeSignal::VALUE);
        Phi = mpPPhi->getStartValue(NodeSignal::VALUE);
        Ub = mpPUb->getStartValue(NodeSignal::VALUE);
        Vb = mpPVb->getStartValue(NodeSignal::VALUE);
        Wb = mpPWb->getStartValue(NodeSignal::VALUE);
        Pb = mpPPb->getStartValue(NodeSignal::VALUE);
        Qb = mpPQb->getStartValue(NodeSignal::VALUE);
        Rb = mpPRb->getStartValue(NodeSignal::VALUE);
        q0 = mpPq0->getStartValue(NodeSignal::VALUE);
        q1 = mpPq1->getStartValue(NodeSignal::VALUE);
        q2 = mpPq2->getStartValue(NodeSignal::VALUE);
        q3 = mpPq3->getStartValue(NodeSignal::VALUE);
        AlphaAttack = mpPAlphaAttack->getStartValue(NodeSignal::VALUE);
        BetaSlip = mpPBetaSlip->getStartValue(NodeSignal::VALUE);
        altitude = mpPaltitude->getStartValue(NodeSignal::VALUE);
        gfx = mpPgfx->getStartValue(NodeSignal::VALUE);
        gfy = mpPgfy->getStartValue(NodeSignal::VALUE);
        gfz = mpPgfz->getStartValue(NodeSignal::VALUE);
        CL1 = mpPCL1->getStartValue(NodeSignal::VALUE);
        Cd1 = mpPCd1->getStartValue(NodeSignal::VALUE);
        Fax = mpPFax->getStartValue(NodeSignal::VALUE);
        Faz = mpPFaz->getStartValue(NodeSignal::VALUE);

        //InitialExpressions
        q0 = Cos(Phi/2.)*Cos(Psi/2.)*Cos(Thetao/2.) + \
Sin(Phi/2.)*Sin(Psi/2.)*Sin(Thetao/2.);
        q1 = Cos(Psi/2.)*Cos(Thetao/2.)*Sin(Phi/2.) - \
Cos(Phi/2.)*Sin(Psi/2.)*Sin(Thetao/2.);
        q2 = Cos(Thetao/2.)*Sin(Phi/2.)*Sin(Psi/2.) + \
Cos(Phi/2.)*Cos(Psi/2.)*Sin(Thetao/2.);
        q3 = Cos(Phi/2.)*Cos(Thetao/2.)*Sin(Psi/2.) - \
Cos(Psi/2.)*Sin(Phi/2.)*Sin(Thetao/2.);

        //LocalExpressions
        v = Sqrt(0.0001 + Power(Ub + vturbx,2) + Power(Vb + vturby,2) + \
Power(vturbz + Wb,2));
        Alpha = Atan2L(vturbz + Wb,0.0001 + Ub + vturbx);
        qpress = (rho*Power(v,2))/2.;
        Beta = Atan2L(Vb + vturby,Sqrt(0.0001 + Power(Ub + vturbx,2) + \
Power(vturbz + Wb,2)));
        mass = Mcargo + Mfuel + mMe;
        xbcg = (mMe*mxbcge + Mcargo*mxcargo + Mfuel*mxfuel)/mass;
        Dragl1 = mS1*qpress*(mCd01/2. + mCdide1*Power(-mde10 + thetaal1,2) - \
mCdide112*(-mde10 + thetaal1)*(-mde120 + thetaal12) + mCdide12*Power(-mde120 \
+ thetaal12,2) + CDragInd(Alpha*mdah1 - \
mia1,mAR1,me1,mCLalpha1,map1,man1,mawp1,mawn1)/2.);
        Dragr1 = mS1*qpress*(mCd01/2. + mCdide1*Power(-mde10 + thetaar1,2) - \
mCdide112*(-mde10 + thetaar1)*(-mde120 + thetaar12) + mCdide12*Power(-mde120 \
+ thetaar12,2) + CDragInd(Alpha*mdah1 - \
mia1,mAR1,me1,mCLalpha1,map1,man1,mawp1,mawn1)/2.);
        Liftl1 = mS1*qpress*(mCLde1*thetaal1 + mCLde12*thetaal12 + \
CLift(Alpha*mdah1 - mia1,mCLalpha1,map1,man1,mawp1,mawn1)/2.);
        Liftr1 = mS1*qpress*(mCLde1*thetaar1 + mCLde12*thetaar12 + \
CLift(Alpha*mdah1 - mia1,mCLalpha1,map1,man1,mawp1,mawn1)/2.);
        Dragl2 = mS2*qpress*(mCd02/2. + CDragInd(Alpha*mdah2 - \
mia2,mAR2,me2,mCLalpha2,map2,man2,mawp2,mawn2)/2.);
        Dragr2 = mS2*qpress*(mCd02/2. + CDragInd(Alpha*mdah2 - \
mia2,mAR2,me2,mCLalpha2,map2,man2,mawp2,mawn2)/2.);
        Liftl2 = mS2*qpress*(mCLde2*thetaal2 + CLift(Alpha*mdah2 - \
mia2,mCLalpha2,map2,man2,mawp2,mawn2)/2.);
        Liftr2 = mS2*qpress*(mCLde2*thetaar2 + CLift(Alpha*mdah2 - \
mia2,mCLalpha2,map2,man2,mawp2,mawn2)/2.);
        Liftb = mCLalphabh*mSbh*qpress*Sin(Alpha);
        Dragb = mCd0b*mSbh*qpress;
        Cfin = mSfin*qpress*CLift(-Beta - \
(mCLdefin*thetafin)/mCLalphafin,mCLalphafin,mafin,mafin,mawfin,mawfin);
        Dragfin = mCd0fin*mSfin*qpress;
        Mdvtheta = (mCLalpha2*mS2*qpress*Power(mxw2 - xbcg,2))/(0.1 + v);
        Mdvpsi = (mCLalphafin*mSfin*qpress*Power(mxwfin - xbcg,2))/(0.1 + v);
        Fx = (-Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - \
Dragr2)*Cos(Alpha)*Cos(Beta) + (thrustl + thrustr)*Cos(dezthrust) - (-Liftb - \
Liftl1 - Liftl2 - Liftr1 - Liftr2)*Sin(Alpha) - Cos(Alpha)*Sin(Beta)*(-Cfin + \
mCLalphabv*mSbv*qpress*Sin(Beta));
        Fy = (-Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - Dragr2)*Sin(Beta) \
+ Cos(Beta)*(-Cfin + mCLalphabv*mSbv*qpress*Sin(Beta));
        Fz = (-Liftb - Liftl1 - Liftl2 - Liftr1 - Liftr2)*Cos(Alpha) + \
(-Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - Dragr2)*Cos(Beta)*Sin(Alpha) - \
Sin(Alpha)*Sin(Beta)*(-Cfin + mCLalphabv*mSbv*qpress*Sin(Beta)) + (thrustl + \
thrustr)*Sin(dezthrust);
        Lb = (Liftl1 - Liftr1)*mrc1 + (Liftl2 - Liftr2)*mrc2 - \
(0.12249999999999998*(mAR1*mCLalpha1*Power(mS1,2) + \
mAR2*mCLalpha2*Power(mS2,2))*qpress*(Pb + wturbx))/(0.1 + v) + myeng*(thrustl \
- thrustr)*Sin(dezthrust);
        Mb = -(Mdvtheta*(Qb + wturby)) + mS1*qpress*(-(mCmde1*thetaal1) - \
mCmde12*thetaal12 - mCmde1*thetaar1 - mCmde12*thetaar12 + CMoment(Alpha*mdah1 \
- mia1,mCm01,mCmfs1,map1,man1,mawp1,mawn1)) + (-mxw1 + xbcg)*((Liftl1 + \
Liftr1)*Cos(Alpha) + (Dragl1 + Dragr1)*Sin(Alpha)) + (-mxw2 + xbcg)*((Liftl2 \
+ Liftr2)*Cos(Alpha) - (Dragl2 + Dragr2)*Sin(Alpha)) + (thrustl + \
thrustr)*(mhthrust - xbcg)*Sin(dezthrust);
        Nb = -(Mdvpsi*(Rb + wturbz)) - Cfin*(mxwfin - xbcg) + myeng*(thrustl \
- thrustr)*Cos(dezthrust) + mrc1*((-Dragl1 + Dragr1)*Cos(Alpha) + (-Liftl1 + \
Liftr1)*Sin(Alpha)) + mrc2*((-Dragl2 + Dragr2)*Cos(Alpha) + (-Liftl2 + \
Liftr2)*Sin(Alpha));

        //Initialize delays
        delayParts1[1] = (-(Fx*mTimestep) + 2*mass*mg0*mTimestep*q0*q2 - \
2*mass*mg0*mTimestep*q1*q3 - 2*mass*Ub - mass*mTimestep*Rb*Vb + \
mass*mTimestep*Qb*Wb - 2*mkground*mTimestep*q0*q2*zcg*onPositive(zcg) + \
2*mkground*mTimestep*q1*q3*zcg*onPositive(zcg))/(2.*mass);
        mDelayedPart11.initialize(mNstep,delayParts1[1]);
        delayParts2[1] = (-(Fy*mTimestep) - 2*mass*mg0*mTimestep*q0*q1 - \
2*mass*mg0*mTimestep*q2*q3 + mass*mTimestep*Rb*Ub - 2*mass*Vb - \
mass*mTimestep*Pb*Wb + 2*mkground*mTimestep*q0*q1*zcg*onPositive(zcg) + \
2*mkground*mTimestep*q2*q3*zcg*onPositive(zcg))/(2.*mass);
        mDelayedPart21.initialize(mNstep,delayParts2[1]);
        delayParts3[1] = (-(Fz*mTimestep) - mass*mg0*mTimestep*Power(q0,2) + \
mass*mg0*mTimestep*Power(q1,2) + mass*mg0*mTimestep*Power(q2,2) - \
mass*mg0*mTimestep*Power(q3,2) - mass*mTimestep*Qb*Ub + mass*mTimestep*Pb*Vb \
- 2*mass*Wb + mkground*mTimestep*Power(q0,2)*zcg*onPositive(zcg) - \
mkground*mTimestep*Power(q1,2)*zcg*onPositive(zcg) - \
mkground*mTimestep*Power(q2,2)*zcg*onPositive(zcg) + \
mkground*mTimestep*Power(q3,2)*zcg*onPositive(zcg))/(2.*mass);
        mDelayedPart31.initialize(mNstep,delayParts3[1]);
        delayParts4[1] = (Lb*mIz*mTimestep + mIxz*mTimestep*Nb - \
2*Power(mIxz,2)*Pb + 2*mIx*mIz*Pb + mIx*mIxz*mTimestep*Pb*Qb - \
mIxz*mIy*mTimestep*Pb*Qb + mIxz*mIz*mTimestep*Pb*Qb - \
Power(mIxz,2)*mTimestep*Qb*Rb + mIy*mIz*mTimestep*Qb*Rb - \
Power(mIz,2)*mTimestep*Qb*Rb)/(2*Power(mIxz,2) - 2*mIx*mIz + \
mIx*mIxz*mTimestep*Qb - mIxz*mIy*mTimestep*Qb + mIxz*mIz*mTimestep*Qb);
        mDelayedPart41.initialize(mNstep,delayParts4[1]);
        delayParts5[1] = (-(Mb*mTimestep) + mIxz*mTimestep*Power(Pb,2) - \
2*mIy*Qb + mIx*mTimestep*Pb*Rb - mIz*mTimestep*Pb*Rb - \
mIxz*mTimestep*Power(Rb,2))/(2.*mIy);
        mDelayedPart51.initialize(mNstep,delayParts5[1]);
        delayParts6[1] = (Lb*mIxz*mTimestep + mIx*mTimestep*Nb + \
Power(mIx,2)*mTimestep*Pb*Qb + Power(mIxz,2)*mTimestep*Pb*Qb - \
mIx*mIy*mTimestep*Pb*Qb - 2*Power(mIxz,2)*Rb + 2*mIx*mIz*Rb - \
mIx*mIxz*mTimestep*Qb*Rb + mIxz*mIy*mTimestep*Qb*Rb - \
mIxz*mIz*mTimestep*Qb*Rb)/(2*Power(mIxz,2) - 2*mIx*mIz - \
mIx*mIxz*mTimestep*Qb + mIxz*mIy*mTimestep*Qb - mIxz*mIz*mTimestep*Qb);
        mDelayedPart61.initialize(mNstep,delayParts6[1]);
        delayParts7[1] = (-4*q0 + mTimestep*Pb*q1 + mTimestep*q2*Qb + \
mTimestep*q3*Rb)/4.;
        mDelayedPart71.initialize(mNstep,delayParts7[1]);
        delayParts8[1] = (-(mTimestep*Pb*q0) - 4*q1 + mTimestep*q3*Qb - \
mTimestep*q2*Rb)/4.;
        mDelayedPart81.initialize(mNstep,delayParts8[1]);
        delayParts9[1] = (-4*q2 - mTimestep*Pb*q3 - mTimestep*q0*Qb + \
mTimestep*q1*Rb)/4.;
        mDelayedPart91.initialize(mNstep,delayParts9[1]);
        delayParts10[1] = (mTimestep*Pb*q2 - 4*q3 - mTimestep*q1*Qb - \
mTimestep*q0*Rb)/4.;
        mDelayedPart101.initialize(mNstep,delayParts10[1]);
        delayParts11[1] = (-(mTimestep*Power(q0,2)*Ub) - \
mTimestep*Power(q1,2)*Ub + mTimestep*Power(q2,2)*Ub + \
mTimestep*Power(q3,2)*Ub - 2*mTimestep*q1*q2*Vb + 2*mTimestep*q0*q3*Vb - \
2*mTimestep*q0*q2*Wb - 2*mTimestep*q1*q3*Wb - 2*xcg)/2.;
        mDelayedPart111.initialize(mNstep,delayParts11[1]);
        delayParts12[1] = (-2*mTimestep*q1*q2*Ub - 2*mTimestep*q0*q3*Ub - \
mTimestep*Power(q0,2)*Vb + mTimestep*Power(q1,2)*Vb - \
mTimestep*Power(q2,2)*Vb + mTimestep*Power(q3,2)*Vb + 2*mTimestep*q0*q1*Wb - \
2*mTimestep*q2*q3*Wb - 2*ycg)/2.;
        mDelayedPart121.initialize(mNstep,delayParts12[1]);
        delayParts13[1] = (2*mTimestep*q0*q2*Ub - 2*mTimestep*q1*q3*Ub - \
2*mTimestep*q0*q1*Vb - 2*mTimestep*q2*q3*Vb - mTimestep*Power(q0,2)*Wb + \
mTimestep*Power(q1,2)*Wb + mTimestep*Power(q2,2)*Wb - \
mTimestep*Power(q3,2)*Wb - 2*zcg)/2.;
        mDelayedPart131.initialize(mNstep,delayParts13[1]);

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];
        delayedPart[6][1] = delayParts6[1];
        delayedPart[7][1] = delayParts7[1];
        delayedPart[8][1] = delayParts8[1];
        delayedPart[9][1] = delayParts9[1];
        delayedPart[10][1] = delayParts10[1];
        delayedPart[11][1] = delayParts11[1];
        delayedPart[12][1] = delayParts12[1];
        delayedPart[13][1] = delayParts13[1];
     }
    void simulateOneTimestep()
     {
        Vec stateVar(13);
        Vec stateVark(13);
        Vec deltaStateVar(13);

        //Read variables from nodes
        //Port Pal1
        toral1 = (*mpND_toral1);
        thetaal1 = (*mpND_thetaal1);
        wal1 = (*mpND_wal1);
        eqInertiaal1 = (*mpND_eqInertiaal1);
        //Port Par1
        torar1 = (*mpND_torar1);
        thetaar1 = (*mpND_thetaar1);
        war1 = (*mpND_war1);
        eqInertiaar1 = (*mpND_eqInertiaar1);
        //Port Pal12
        toral12 = (*mpND_toral12);
        thetaal12 = (*mpND_thetaal12);
        wal12 = (*mpND_wal12);
        eqInertiaal12 = (*mpND_eqInertiaal12);
        //Port Par12
        torar12 = (*mpND_torar12);
        thetaar12 = (*mpND_thetaar12);
        war12 = (*mpND_war12);
        eqInertiaar12 = (*mpND_eqInertiaar12);
        //Port Pal2
        toral2 = (*mpND_toral2);
        thetaal2 = (*mpND_thetaal2);
        wal2 = (*mpND_wal2);
        eqInertiaal2 = (*mpND_eqInertiaal2);
        //Port Par2
        torar2 = (*mpND_torar2);
        thetaar2 = (*mpND_thetaar2);
        war2 = (*mpND_war2);
        eqInertiaar2 = (*mpND_eqInertiaar2);
        //Port Pfin
        torfin = (*mpND_torfin);
        thetafin = (*mpND_thetafin);
        wfin = (*mpND_wfin);
        eqInertiafin = (*mpND_eqInertiafin);

        //Read inputVariables from nodes
        thrustl = (*mpND_thrustl);
        thrustr = (*mpND_thrustr);
        dezthrust = (*mpND_dezthrust);
        Mfuel = (*mpND_Mfuel);
        Mcargo = (*mpND_Mcargo);
        rho = (*mpND_rho);
        vturbx = (*mpND_vturbx);
        vturby = (*mpND_vturby);
        vturbz = (*mpND_vturbz);
        wturbx = (*mpND_wturbx);
        wturby = (*mpND_wturby);
        wturbz = (*mpND_wturbz);

        //LocalExpressions
        v = Sqrt(0.0001 + Power(Ub + vturbx,2) + Power(Vb + vturby,2) + \
Power(vturbz + Wb,2));
        Alpha = Atan2L(vturbz + Wb,0.0001 + Ub + vturbx);
        qpress = (rho*Power(v,2))/2.;
        Beta = Atan2L(Vb + vturby,Sqrt(0.0001 + Power(Ub + vturbx,2) + \
Power(vturbz + Wb,2)));
        mass = Mcargo + Mfuel + mMe;
        xbcg = (mMe*mxbcge + Mcargo*mxcargo + Mfuel*mxfuel)/mass;
        Dragl1 = mS1*qpress*(mCd01/2. + mCdide1*Power(-mde10 + thetaal1,2) - \
mCdide112*(-mde10 + thetaal1)*(-mde120 + thetaal12) + mCdide12*Power(-mde120 \
+ thetaal12,2) + CDragInd(Alpha*mdah1 - \
mia1,mAR1,me1,mCLalpha1,map1,man1,mawp1,mawn1)/2.);
        Dragr1 = mS1*qpress*(mCd01/2. + mCdide1*Power(-mde10 + thetaar1,2) - \
mCdide112*(-mde10 + thetaar1)*(-mde120 + thetaar12) + mCdide12*Power(-mde120 \
+ thetaar12,2) + CDragInd(Alpha*mdah1 - \
mia1,mAR1,me1,mCLalpha1,map1,man1,mawp1,mawn1)/2.);
        Liftl1 = mS1*qpress*(mCLde1*thetaal1 + mCLde12*thetaal12 + \
CLift(Alpha*mdah1 - mia1,mCLalpha1,map1,man1,mawp1,mawn1)/2.);
        Liftr1 = mS1*qpress*(mCLde1*thetaar1 + mCLde12*thetaar12 + \
CLift(Alpha*mdah1 - mia1,mCLalpha1,map1,man1,mawp1,mawn1)/2.);
        Dragl2 = mS2*qpress*(mCd02/2. + CDragInd(Alpha*mdah2 - \
mia2,mAR2,me2,mCLalpha2,map2,man2,mawp2,mawn2)/2.);
        Dragr2 = mS2*qpress*(mCd02/2. + CDragInd(Alpha*mdah2 - \
mia2,mAR2,me2,mCLalpha2,map2,man2,mawp2,mawn2)/2.);
        Liftl2 = mS2*qpress*(mCLde2*thetaal2 + CLift(Alpha*mdah2 - \
mia2,mCLalpha2,map2,man2,mawp2,mawn2)/2.);
        Liftr2 = mS2*qpress*(mCLde2*thetaar2 + CLift(Alpha*mdah2 - \
mia2,mCLalpha2,map2,man2,mawp2,mawn2)/2.);
        Liftb = mCLalphabh*mSbh*qpress*Sin(Alpha);
        Dragb = mCd0b*mSbh*qpress;
        Cfin = mSfin*qpress*CLift(-Beta - \
(mCLdefin*thetafin)/mCLalphafin,mCLalphafin,mafin,mafin,mawfin,mawfin);
        Dragfin = mCd0fin*mSfin*qpress;
        Mdvtheta = (mCLalpha2*mS2*qpress*Power(mxw2 - xbcg,2))/(0.1 + v);
        Mdvpsi = (mCLalphafin*mSfin*qpress*Power(mxwfin - xbcg,2))/(0.1 + v);
        Fx = (-Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - \
Dragr2)*Cos(Alpha)*Cos(Beta) + (thrustl + thrustr)*Cos(dezthrust) - (-Liftb - \
Liftl1 - Liftl2 - Liftr1 - Liftr2)*Sin(Alpha) - Cos(Alpha)*Sin(Beta)*(-Cfin + \
mCLalphabv*mSbv*qpress*Sin(Beta));
        Fy = (-Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - Dragr2)*Sin(Beta) \
+ Cos(Beta)*(-Cfin + mCLalphabv*mSbv*qpress*Sin(Beta));
        Fz = (-Liftb - Liftl1 - Liftl2 - Liftr1 - Liftr2)*Cos(Alpha) + \
(-Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - Dragr2)*Cos(Beta)*Sin(Alpha) - \
Sin(Alpha)*Sin(Beta)*(-Cfin + mCLalphabv*mSbv*qpress*Sin(Beta)) + (thrustl + \
thrustr)*Sin(dezthrust);
        Lb = (Liftl1 - Liftr1)*mrc1 + (Liftl2 - Liftr2)*mrc2 - \
(0.12249999999999998*(mAR1*mCLalpha1*Power(mS1,2) + \
mAR2*mCLalpha2*Power(mS2,2))*qpress*(Pb + wturbx))/(0.1 + v) + myeng*(thrustl \
- thrustr)*Sin(dezthrust);
        Mb = -(Mdvtheta*(Qb + wturby)) + mS1*qpress*(-(mCmde1*thetaal1) - \
mCmde12*thetaal12 - mCmde1*thetaar1 - mCmde12*thetaar12 + CMoment(Alpha*mdah1 \
- mia1,mCm01,mCmfs1,map1,man1,mawp1,mawn1)) + (-mxw1 + xbcg)*((Liftl1 + \
Liftr1)*Cos(Alpha) + (Dragl1 + Dragr1)*Sin(Alpha)) + (-mxw2 + xbcg)*((Liftl2 \
+ Liftr2)*Cos(Alpha) - (Dragl2 + Dragr2)*Sin(Alpha)) + (thrustl + \
thrustr)*(mhthrust - xbcg)*Sin(dezthrust);
        Nb = -(Mdvpsi*(Rb + wturbz)) - Cfin*(mxwfin - xbcg) + myeng*(thrustl \
- thrustr)*Cos(dezthrust) + mrc1*((-Dragl1 + Dragr1)*Cos(Alpha) + (-Liftl1 + \
Liftr1)*Sin(Alpha)) + mrc2*((-Dragl2 + Dragr2)*Cos(Alpha) + (-Liftl2 + \
Liftr2)*Sin(Alpha));

        //Initializing variable vector for Newton-Raphson
        stateVark[0] = Ub;
        stateVark[1] = Vb;
        stateVark[2] = Wb;
        stateVark[3] = Pb;
        stateVark[4] = Qb;
        stateVark[5] = Rb;
        stateVark[6] = q0;
        stateVark[7] = q1;
        stateVark[8] = q2;
        stateVark[9] = q3;
        stateVark[10] = xcg;
        stateVark[11] = ycg;
        stateVark[12] = zcg;

        //Iterative solution using Newton-Rapshson
        for(iter=1;iter<=mNoiter;iter++)
        {
         //Aircraft6DOF
         //Differential-algebraic system of equation parts

          //Assemble differential-algebraic equations
          systemEquations[0] =Ub - (mTimestep*(Fx + mass*(-2*mg0*q0*q2 + \
2*mg0*q1*q3 + Rb*Vb - Qb*Wb) + 2*mkground*(q0*q2 - \
q1*q3)*zcg*onPositive(zcg)))/(2.*mass) + delayedPart[1][1];
          systemEquations[1] =Vb - (mTimestep*(Fy + mass*(2*mg0*q0*q1 + \
2*mg0*q2*q3 - Rb*Ub + Pb*Wb) - 2*mkground*(q0*q1 + \
q2*q3)*zcg*onPositive(zcg)))/(2.*mass) + delayedPart[2][1];
          systemEquations[2] =Wb - (mTimestep*(Fz + mass*(mg0*(Power(q0,2) - \
Power(q1,2) - Power(q2,2) + Power(q3,2)) + Qb*Ub - Pb*Vb) + \
mkground*(-Power(q0,2) + Power(q1,2) + Power(q2,2) - \
Power(q3,2))*zcg*onPositive(zcg)))/(2.*mass) + delayedPart[3][1];
          systemEquations[3] =Pb + (mTimestep*(Lb*mIz + mIxz*Nb - \
Power(mIxz,2)*Qb*Rb + (mIy - mIz)*mIz*Qb*Rb))/(2*Power(mIxz,2) - 2*mIx*mIz + \
mIxz*(mIx - mIy + mIz)*mTimestep*Qb) + delayedPart[4][1];
          systemEquations[4] =Qb - (mTimestep*(Mb + (-mIx + mIz)*Pb*Rb + \
mIxz*(-Power(Pb,2) + Power(Rb,2))))/(2.*mIy) + delayedPart[5][1];
          systemEquations[5] =-((mTimestep*(Lb*mIxz + Power(mIx,2)*Pb*Qb + \
Power(mIxz,2)*Pb*Qb + mIx*(Nb - mIy*Pb*Qb)))/(-2*Power(mIxz,2) + 2*mIx*mIz + \
mIxz*(mIx - mIy + mIz)*mTimestep*Qb)) + Rb + delayedPart[6][1];
          systemEquations[6] =q0 + (mTimestep*(Pb*q1 + q2*Qb + q3*Rb))/4. + \
delayedPart[7][1];
          systemEquations[7] =q1 - (mTimestep*(Pb*q0 - q3*Qb + q2*Rb))/4. + \
delayedPart[8][1];
          systemEquations[8] =q2 - (mTimestep*(Pb*q3 + q0*Qb - q1*Rb))/4. + \
delayedPart[9][1];
          systemEquations[9] =q3 + (mTimestep*(Pb*q2 - q1*Qb - q0*Rb))/4. + \
delayedPart[10][1];
          systemEquations[10] =-(mTimestep*(Power(q0,2)*Ub + Power(q1,2)*Ub - \
(Power(q2,2) + Power(q3,2))*Ub + q0*(-2*q3*Vb + 2*q2*Wb) + 2*q1*(q2*Vb + \
q3*Wb)))/2. + xcg + delayedPart[11][1];
          systemEquations[11] =(mTimestep*(-2*q1*q2*Ub - 2*q0*q3*Ub - \
Power(q0,2)*Vb + Power(q1,2)*Vb - Power(q2,2)*Vb + Power(q3,2)*Vb + \
2*q0*q1*Wb - 2*q2*q3*Wb))/2. + ycg + delayedPart[12][1];
          systemEquations[12] =-(mTimestep*(-2*q0*q2*Ub + 2*q1*q3*Ub + \
2*q0*q1*Vb + 2*q2*q3*Vb + Power(q0,2)*Wb - Power(q1,2)*Wb - Power(q2,2)*Wb + \
Power(q3,2)*Wb))/2. + zcg + delayedPart[13][1];

          //Jacobian matrix
          jacobianMatrix[0][0] = 1;
          jacobianMatrix[0][1] = -(mTimestep*Rb)/2.;
          jacobianMatrix[0][2] = (mTimestep*Qb)/2.;
          jacobianMatrix[0][3] = 0;
          jacobianMatrix[0][4] = (mTimestep*Wb)/2.;
          jacobianMatrix[0][5] = -(mTimestep*Vb)/2.;
          jacobianMatrix[0][6] = -(mTimestep*(-2*mass*mg0*q2 + \
2*mkground*q2*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[0][7] = -(mTimestep*(2*mass*mg0*q3 - \
2*mkground*q3*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[0][8] = -(mTimestep*(-2*mass*mg0*q0 + \
2*mkground*q0*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[0][9] = -(mTimestep*(2*mass*mg0*q1 - \
2*mkground*q1*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[0][10] = 0;
          jacobianMatrix[0][11] = 0;
          jacobianMatrix[0][12] = -((mkground*mTimestep*(q0*q2 - \
q1*q3)*onPositive(zcg))/mass);
          jacobianMatrix[1][0] = (mTimestep*Rb)/2.;
          jacobianMatrix[1][1] = 1;
          jacobianMatrix[1][2] = -(mTimestep*Pb)/2.;
          jacobianMatrix[1][3] = -(mTimestep*Wb)/2.;
          jacobianMatrix[1][4] = 0;
          jacobianMatrix[1][5] = (mTimestep*Ub)/2.;
          jacobianMatrix[1][6] = -(mTimestep*(2*mass*mg0*q1 - \
2*mkground*q1*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[1][7] = -(mTimestep*(2*mass*mg0*q0 - \
2*mkground*q0*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[1][8] = -(mTimestep*(2*mass*mg0*q3 - \
2*mkground*q3*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[1][9] = -(mTimestep*(2*mass*mg0*q2 - \
2*mkground*q2*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[1][10] = 0;
          jacobianMatrix[1][11] = 0;
          jacobianMatrix[1][12] = (mkground*mTimestep*(q0*q1 + \
q2*q3)*onPositive(zcg))/mass;
          jacobianMatrix[2][0] = -(mTimestep*Qb)/2.;
          jacobianMatrix[2][1] = (mTimestep*Pb)/2.;
          jacobianMatrix[2][2] = 1;
          jacobianMatrix[2][3] = (mTimestep*Vb)/2.;
          jacobianMatrix[2][4] = -(mTimestep*Ub)/2.;
          jacobianMatrix[2][5] = 0;
          jacobianMatrix[2][6] = -(mTimestep*(2*mass*mg0*q0 - \
2*mkground*q0*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[2][7] = -(mTimestep*(-2*mass*mg0*q1 + \
2*mkground*q1*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[2][8] = -(mTimestep*(-2*mass*mg0*q2 + \
2*mkground*q2*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[2][9] = -(mTimestep*(2*mass*mg0*q3 - \
2*mkground*q3*zcg*onPositive(zcg)))/(2.*mass);
          jacobianMatrix[2][10] = 0;
          jacobianMatrix[2][11] = 0;
          jacobianMatrix[2][12] = -(mkground*mTimestep*(-Power(q0,2) + \
Power(q1,2) + Power(q2,2) - Power(q3,2))*onPositive(zcg))/(2.*mass);
          jacobianMatrix[3][0] = 0;
          jacobianMatrix[3][1] = 0;
          jacobianMatrix[3][2] = 0;
          jacobianMatrix[3][3] = 1;
          jacobianMatrix[3][4] = (mTimestep*(-(Power(mIxz,2)*Rb) + (mIy - \
mIz)*mIz*Rb))/(2*Power(mIxz,2) - 2*mIx*mIz + mIxz*(mIx - mIy + \
mIz)*mTimestep*Qb) - (mIxz*(mIx - mIy + mIz)*Power(mTimestep,2)*(Lb*mIz + \
mIxz*Nb - Power(mIxz,2)*Qb*Rb + (mIy - mIz)*mIz*Qb*Rb))/Power(2*Power(mIxz,2) \
- 2*mIx*mIz + mIxz*(mIx - mIy + mIz)*mTimestep*Qb,2);
          jacobianMatrix[3][5] = (mTimestep*(-(Power(mIxz,2)*Qb) + (mIy - \
mIz)*mIz*Qb))/(2*Power(mIxz,2) - 2*mIx*mIz + mIxz*(mIx - mIy + \
mIz)*mTimestep*Qb);
          jacobianMatrix[3][6] = 0;
          jacobianMatrix[3][7] = 0;
          jacobianMatrix[3][8] = 0;
          jacobianMatrix[3][9] = 0;
          jacobianMatrix[3][10] = 0;
          jacobianMatrix[3][11] = 0;
          jacobianMatrix[3][12] = 0;
          jacobianMatrix[4][0] = 0;
          jacobianMatrix[4][1] = 0;
          jacobianMatrix[4][2] = 0;
          jacobianMatrix[4][3] = -(mTimestep*(-2*mIxz*Pb + (-mIx + \
mIz)*Rb))/(2.*mIy);
          jacobianMatrix[4][4] = 1;
          jacobianMatrix[4][5] = -(mTimestep*((-mIx + mIz)*Pb + \
2*mIxz*Rb))/(2.*mIy);
          jacobianMatrix[4][6] = 0;
          jacobianMatrix[4][7] = 0;
          jacobianMatrix[4][8] = 0;
          jacobianMatrix[4][9] = 0;
          jacobianMatrix[4][10] = 0;
          jacobianMatrix[4][11] = 0;
          jacobianMatrix[4][12] = 0;
          jacobianMatrix[5][0] = 0;
          jacobianMatrix[5][1] = 0;
          jacobianMatrix[5][2] = 0;
          jacobianMatrix[5][3] = -((mTimestep*(Power(mIx,2)*Qb + \
Power(mIxz,2)*Qb - mIx*mIy*Qb))/(-2*Power(mIxz,2) + 2*mIx*mIz + mIxz*(mIx - \
mIy + mIz)*mTimestep*Qb));
          jacobianMatrix[5][4] = -((mTimestep*(Power(mIx,2)*Pb + \
Power(mIxz,2)*Pb - mIx*mIy*Pb))/(-2*Power(mIxz,2) + 2*mIx*mIz + mIxz*(mIx - \
mIy + mIz)*mTimestep*Qb)) + (mIxz*(mIx - mIy + \
mIz)*Power(mTimestep,2)*(Lb*mIxz + Power(mIx,2)*Pb*Qb + Power(mIxz,2)*Pb*Qb + \
mIx*(Nb - mIy*Pb*Qb)))/Power(-2*Power(mIxz,2) + 2*mIx*mIz + mIxz*(mIx - mIy + \
mIz)*mTimestep*Qb,2);
          jacobianMatrix[5][5] = 1;
          jacobianMatrix[5][6] = 0;
          jacobianMatrix[5][7] = 0;
          jacobianMatrix[5][8] = 0;
          jacobianMatrix[5][9] = 0;
          jacobianMatrix[5][10] = 0;
          jacobianMatrix[5][11] = 0;
          jacobianMatrix[5][12] = 0;
          jacobianMatrix[6][0] = 0;
          jacobianMatrix[6][1] = 0;
          jacobianMatrix[6][2] = 0;
          jacobianMatrix[6][3] = (mTimestep*q1)/4.;
          jacobianMatrix[6][4] = (mTimestep*q2)/4.;
          jacobianMatrix[6][5] = (mTimestep*q3)/4.;
          jacobianMatrix[6][6] = 1;
          jacobianMatrix[6][7] = (mTimestep*Pb)/4.;
          jacobianMatrix[6][8] = (mTimestep*Qb)/4.;
          jacobianMatrix[6][9] = (mTimestep*Rb)/4.;
          jacobianMatrix[6][10] = 0;
          jacobianMatrix[6][11] = 0;
          jacobianMatrix[6][12] = 0;
          jacobianMatrix[7][0] = 0;
          jacobianMatrix[7][1] = 0;
          jacobianMatrix[7][2] = 0;
          jacobianMatrix[7][3] = -(mTimestep*q0)/4.;
          jacobianMatrix[7][4] = (mTimestep*q3)/4.;
          jacobianMatrix[7][5] = -(mTimestep*q2)/4.;
          jacobianMatrix[7][6] = -(mTimestep*Pb)/4.;
          jacobianMatrix[7][7] = 1;
          jacobianMatrix[7][8] = -(mTimestep*Rb)/4.;
          jacobianMatrix[7][9] = (mTimestep*Qb)/4.;
          jacobianMatrix[7][10] = 0;
          jacobianMatrix[7][11] = 0;
          jacobianMatrix[7][12] = 0;
          jacobianMatrix[8][0] = 0;
          jacobianMatrix[8][1] = 0;
          jacobianMatrix[8][2] = 0;
          jacobianMatrix[8][3] = -(mTimestep*q3)/4.;
          jacobianMatrix[8][4] = -(mTimestep*q0)/4.;
          jacobianMatrix[8][5] = (mTimestep*q1)/4.;
          jacobianMatrix[8][6] = -(mTimestep*Qb)/4.;
          jacobianMatrix[8][7] = (mTimestep*Rb)/4.;
          jacobianMatrix[8][8] = 1;
          jacobianMatrix[8][9] = -(mTimestep*Pb)/4.;
          jacobianMatrix[8][10] = 0;
          jacobianMatrix[8][11] = 0;
          jacobianMatrix[8][12] = 0;
          jacobianMatrix[9][0] = 0;
          jacobianMatrix[9][1] = 0;
          jacobianMatrix[9][2] = 0;
          jacobianMatrix[9][3] = (mTimestep*q2)/4.;
          jacobianMatrix[9][4] = -(mTimestep*q1)/4.;
          jacobianMatrix[9][5] = -(mTimestep*q0)/4.;
          jacobianMatrix[9][6] = -(mTimestep*Rb)/4.;
          jacobianMatrix[9][7] = -(mTimestep*Qb)/4.;
          jacobianMatrix[9][8] = (mTimestep*Pb)/4.;
          jacobianMatrix[9][9] = 1;
          jacobianMatrix[9][10] = 0;
          jacobianMatrix[9][11] = 0;
          jacobianMatrix[9][12] = 0;
          jacobianMatrix[10][0] = -(mTimestep*(Power(q0,2) + Power(q1,2) - \
Power(q2,2) - Power(q3,2)))/2.;
          jacobianMatrix[10][1] = -(mTimestep*(2*q1*q2 - 2*q0*q3))/2.;
          jacobianMatrix[10][2] = -(mTimestep*(2*q0*q2 + 2*q1*q3))/2.;
          jacobianMatrix[10][3] = 0;
          jacobianMatrix[10][4] = 0;
          jacobianMatrix[10][5] = 0;
          jacobianMatrix[10][6] = -(mTimestep*(2*q0*Ub - 2*q3*Vb + \
2*q2*Wb))/2.;
          jacobianMatrix[10][7] = -(mTimestep*(2*q1*Ub + 2*(q2*Vb + \
q3*Wb)))/2.;
          jacobianMatrix[10][8] = -(mTimestep*(-2*q2*Ub + 2*q1*Vb + \
2*q0*Wb))/2.;
          jacobianMatrix[10][9] = -(mTimestep*(-2*q3*Ub - 2*q0*Vb + \
2*q1*Wb))/2.;
          jacobianMatrix[10][10] = 1;
          jacobianMatrix[10][11] = 0;
          jacobianMatrix[10][12] = 0;
          jacobianMatrix[11][0] = (mTimestep*(-2*q1*q2 - 2*q0*q3))/2.;
          jacobianMatrix[11][1] = (mTimestep*(-Power(q0,2) + Power(q1,2) - \
Power(q2,2) + Power(q3,2)))/2.;
          jacobianMatrix[11][2] = (mTimestep*(2*q0*q1 - 2*q2*q3))/2.;
          jacobianMatrix[11][3] = 0;
          jacobianMatrix[11][4] = 0;
          jacobianMatrix[11][5] = 0;
          jacobianMatrix[11][6] = (mTimestep*(-2*q3*Ub - 2*q0*Vb + \
2*q1*Wb))/2.;
          jacobianMatrix[11][7] = (mTimestep*(-2*q2*Ub + 2*q1*Vb + \
2*q0*Wb))/2.;
          jacobianMatrix[11][8] = (mTimestep*(-2*q1*Ub - 2*q2*Vb - \
2*q3*Wb))/2.;
          jacobianMatrix[11][9] = (mTimestep*(-2*q0*Ub + 2*q3*Vb - \
2*q2*Wb))/2.;
          jacobianMatrix[11][10] = 0;
          jacobianMatrix[11][11] = 1;
          jacobianMatrix[11][12] = 0;
          jacobianMatrix[12][0] = -(mTimestep*(-2*q0*q2 + 2*q1*q3))/2.;
          jacobianMatrix[12][1] = -(mTimestep*(2*q0*q1 + 2*q2*q3))/2.;
          jacobianMatrix[12][2] = -(mTimestep*(Power(q0,2) - Power(q1,2) - \
Power(q2,2) + Power(q3,2)))/2.;
          jacobianMatrix[12][3] = 0;
          jacobianMatrix[12][4] = 0;
          jacobianMatrix[12][5] = 0;
          jacobianMatrix[12][6] = -(mTimestep*(-2*q2*Ub + 2*q1*Vb + \
2*q0*Wb))/2.;
          jacobianMatrix[12][7] = -(mTimestep*(2*q3*Ub + 2*q0*Vb - \
2*q1*Wb))/2.;
          jacobianMatrix[12][8] = -(mTimestep*(-2*q0*Ub + 2*q3*Vb - \
2*q2*Wb))/2.;
          jacobianMatrix[12][9] = -(mTimestep*(2*q1*Ub + 2*q2*Vb + \
2*q3*Wb))/2.;
          jacobianMatrix[12][10] = 0;
          jacobianMatrix[12][11] = 0;
          jacobianMatrix[12][12] = 1;

          //Solving equation using LU-faktorisation
          mpSolver->solve(jacobianMatrix, systemEquations, stateVark, iter);
          Ub=stateVark[0];
          Vb=stateVark[1];
          Wb=stateVark[2];
          Pb=stateVark[3];
          Qb=stateVark[4];
          Rb=stateVark[5];
          q0=stateVark[6];
          q1=stateVark[7];
          q2=stateVark[8];
          q3=stateVark[9];
          xcg=stateVark[10];
          ycg=stateVark[11];
          zcg=stateVark[12];
          //Expressions
          cal1 = mCLde1*Power(mlc1,2)*mS1*qpress*(-Alpha + thetaal1);
          car1 = mCLde1*Power(mlc1,2)*mS1*qpress*(-Alpha + thetaar1);
          cal12 = mCLde12*Power(mlc12,2)*mS1*qpress*(-Alpha + thetaal12);
          car12 = mCLde12*Power(mlc12,2)*mS1*qpress*(-Alpha + thetaar12);
          cal2 = mCLde2*Power(mlc2,2)*mS2*qpress*(-Alpha + thetaal2);
          car2 = mCLde2*Power(mlc2,2)*mS2*qpress*(-Alpha + thetaar2);
          cfin = mCLdefin*Power(mlcfin,2)*mSfin*qpress*(-Beta + thetafin);
          vx = (Power(q0,2) + Power(q1,2) - Power(q2,2) - Power(q3,2))*Ub + \
2*(q1*q2 - q0*q3)*Vb + 2*(q0*q2 + q1*q3)*Wb;
          vy = 2*(q1*q2 + q0*q3)*Ub + (Power(q0,2) - Power(q1,2) + \
Power(q2,2) - Power(q3,2))*Vb + 2*(-(q0*q1) + q2*q3)*Wb;
          vz = 2*(-(q0*q2) + q1*q3)*Ub + 2*(q0*q1 + q2*q3)*Vb + (Power(q0,2) \
- Power(q1,2) - Power(q2,2) + Power(q3,2))*Wb;
          AlphaAttack = Alpha;
          BetaSlip = Beta;
          altitude = -zcg;
          Phi = Atan2L(2*(q0*q1 + q2*q3),Power(q0,2) - Power(q1,2) - \
Power(q2,2) + Power(q3,2));
          Thetao = ArcSinL(2*(q0*q2 - q1*q3));
          Psi = Atan2L(2*(q1*q2 + q0*q3),Power(q0,2) + Power(q1,2) - \
Power(q2,2) - Power(q3,2));
          gfx = Fx/mass;
          gfy = Fy/mass;
          gfz = Fz/mass;
          Faz = -Liftb - Liftl1 - Liftl2 - Liftr1 - Liftr2;
          Fax = -Dragb - Dragfin - Dragl1 - Dragl2 - Dragr1 - Dragr2;
          CL1 = mCLde1*thetaal1 + mCLde12*thetaal12 + mCLde1*thetaar1 + \
mCLde12*thetaar12 + CLift(Alpha*mdah1 - \
mia1,mCLalpha1,map1,man1,mawp1,mawn1);
          Cd1 = mCd01 + mCdide1*Power(-mde10 + thetaal1,2) - \
mCdide112*(-mde10 + thetaal1)*(-mde120 + thetaal12) + mCdide12*Power(-mde120 \
+ thetaal12,2) + mCdide1*Power(-mde10 + thetaar1,2) - mCdide112*(-mde10 + \
thetaar1)*(-mde120 + thetaar12) + mCdide12*Power(-mde120 + thetaar12,2) + \
CDragInd(Alpha*mdah1 - mia1,mAR1,me1,mCLalpha1,map1,man1,mawp1,mawn1);
          Zcfin = mCLdefin*Power(mlcfin,2)*mSfin*mTimestep*qpress;
          Zcal1 = mCLde1*Power(mlc1,2)*mS1*mTimestep*qpress;
          Zcar1 = mCLde1*Power(mlc1,2)*mS1*mTimestep*qpress;
          Zcal12 = mCLde12*Power(mlc12,2)*mS1*mTimestep*qpress;
          Zcar12 = mCLde12*Power(mlc12,2)*mS1*mTimestep*qpress;
          Zcal2 = mCLde2*Power(mlc2,2)*mS2*mTimestep*qpress;
          Zcar2 = mCLde2*Power(mlc2,2)*mS2*mTimestep*qpress;
        }

        //Calculate the delayed parts
        delayParts1[1] = (-(Fx*mTimestep) + 2*mass*mg0*mTimestep*q0*q2 - \
2*mass*mg0*mTimestep*q1*q3 - 2*mass*Ub - mass*mTimestep*Rb*Vb + \
mass*mTimestep*Qb*Wb - 2*mkground*mTimestep*q0*q2*zcg*onPositive(zcg) + \
2*mkground*mTimestep*q1*q3*zcg*onPositive(zcg))/(2.*mass);
        delayParts2[1] = (-(Fy*mTimestep) - 2*mass*mg0*mTimestep*q0*q1 - \
2*mass*mg0*mTimestep*q2*q3 + mass*mTimestep*Rb*Ub - 2*mass*Vb - \
mass*mTimestep*Pb*Wb + 2*mkground*mTimestep*q0*q1*zcg*onPositive(zcg) + \
2*mkground*mTimestep*q2*q3*zcg*onPositive(zcg))/(2.*mass);
        delayParts3[1] = (-(Fz*mTimestep) - mass*mg0*mTimestep*Power(q0,2) + \
mass*mg0*mTimestep*Power(q1,2) + mass*mg0*mTimestep*Power(q2,2) - \
mass*mg0*mTimestep*Power(q3,2) - mass*mTimestep*Qb*Ub + mass*mTimestep*Pb*Vb \
- 2*mass*Wb + mkground*mTimestep*Power(q0,2)*zcg*onPositive(zcg) - \
mkground*mTimestep*Power(q1,2)*zcg*onPositive(zcg) - \
mkground*mTimestep*Power(q2,2)*zcg*onPositive(zcg) + \
mkground*mTimestep*Power(q3,2)*zcg*onPositive(zcg))/(2.*mass);
        delayParts4[1] = (Lb*mIz*mTimestep + mIxz*mTimestep*Nb - \
2*Power(mIxz,2)*Pb + 2*mIx*mIz*Pb + mIx*mIxz*mTimestep*Pb*Qb - \
mIxz*mIy*mTimestep*Pb*Qb + mIxz*mIz*mTimestep*Pb*Qb - \
Power(mIxz,2)*mTimestep*Qb*Rb + mIy*mIz*mTimestep*Qb*Rb - \
Power(mIz,2)*mTimestep*Qb*Rb)/(2*Power(mIxz,2) - 2*mIx*mIz + \
mIx*mIxz*mTimestep*Qb - mIxz*mIy*mTimestep*Qb + mIxz*mIz*mTimestep*Qb);
        delayParts5[1] = (-(Mb*mTimestep) + mIxz*mTimestep*Power(Pb,2) - \
2*mIy*Qb + mIx*mTimestep*Pb*Rb - mIz*mTimestep*Pb*Rb - \
mIxz*mTimestep*Power(Rb,2))/(2.*mIy);
        delayParts6[1] = (Lb*mIxz*mTimestep + mIx*mTimestep*Nb + \
Power(mIx,2)*mTimestep*Pb*Qb + Power(mIxz,2)*mTimestep*Pb*Qb - \
mIx*mIy*mTimestep*Pb*Qb - 2*Power(mIxz,2)*Rb + 2*mIx*mIz*Rb - \
mIx*mIxz*mTimestep*Qb*Rb + mIxz*mIy*mTimestep*Qb*Rb - \
mIxz*mIz*mTimestep*Qb*Rb)/(2*Power(mIxz,2) - 2*mIx*mIz - \
mIx*mIxz*mTimestep*Qb + mIxz*mIy*mTimestep*Qb - mIxz*mIz*mTimestep*Qb);
        delayParts7[1] = (-4*q0 + mTimestep*Pb*q1 + mTimestep*q2*Qb + \
mTimestep*q3*Rb)/4.;
        delayParts8[1] = (-(mTimestep*Pb*q0) - 4*q1 + mTimestep*q3*Qb - \
mTimestep*q2*Rb)/4.;
        delayParts9[1] = (-4*q2 - mTimestep*Pb*q3 - mTimestep*q0*Qb + \
mTimestep*q1*Rb)/4.;
        delayParts10[1] = (mTimestep*Pb*q2 - 4*q3 - mTimestep*q1*Qb - \
mTimestep*q0*Rb)/4.;
        delayParts11[1] = (-(mTimestep*Power(q0,2)*Ub) - \
mTimestep*Power(q1,2)*Ub + mTimestep*Power(q2,2)*Ub + \
mTimestep*Power(q3,2)*Ub - 2*mTimestep*q1*q2*Vb + 2*mTimestep*q0*q3*Vb - \
2*mTimestep*q0*q2*Wb - 2*mTimestep*q1*q3*Wb - 2*xcg)/2.;
        delayParts12[1] = (-2*mTimestep*q1*q2*Ub - 2*mTimestep*q0*q3*Ub - \
mTimestep*Power(q0,2)*Vb + mTimestep*Power(q1,2)*Vb - \
mTimestep*Power(q2,2)*Vb + mTimestep*Power(q3,2)*Vb + 2*mTimestep*q0*q1*Wb - \
2*mTimestep*q2*q3*Wb - 2*ycg)/2.;
        delayParts13[1] = (2*mTimestep*q0*q2*Ub - 2*mTimestep*q1*q3*Ub - \
2*mTimestep*q0*q1*Vb - 2*mTimestep*q2*q3*Vb - mTimestep*Power(q0,2)*Wb + \
mTimestep*Power(q1,2)*Wb + mTimestep*Power(q2,2)*Wb - \
mTimestep*Power(q3,2)*Wb - 2*zcg)/2.;

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];
        delayedPart[6][1] = delayParts6[1];
        delayedPart[7][1] = delayParts7[1];
        delayedPart[8][1] = delayParts8[1];
        delayedPart[9][1] = delayParts9[1];
        delayedPart[10][1] = delayParts10[1];
        delayedPart[11][1] = delayParts11[1];
        delayedPart[12][1] = delayParts12[1];
        delayedPart[13][1] = delayParts13[1];

        //Write new values to nodes
        //Port Pal1
        (*mpND_cal1)=cal1;
        (*mpND_Zcal1)=Zcal1;
        //Port Par1
        (*mpND_car1)=car1;
        (*mpND_Zcar1)=Zcar1;
        //Port Pal12
        (*mpND_cal12)=cal12;
        (*mpND_Zcal12)=Zcal12;
        //Port Par12
        (*mpND_car12)=car12;
        (*mpND_Zcar12)=Zcar12;
        //Port Pal2
        (*mpND_cal2)=cal2;
        (*mpND_Zcal2)=Zcal2;
        //Port Par2
        (*mpND_car2)=car2;
        (*mpND_Zcar2)=Zcar2;
        //Port Pfin
        (*mpND_cfin)=cfin;
        (*mpND_Zcfin)=Zcfin;
        //outputVariables
        (*mpND_xcg)=xcg;
        (*mpND_ycg)=ycg;
        (*mpND_zcg)=zcg;
        (*mpND_vx)=vx;
        (*mpND_vy)=vy;
        (*mpND_vz)=vz;
        (*mpND_Psi)=Psi;
        (*mpND_Thetao)=Thetao;
        (*mpND_Phi)=Phi;
        (*mpND_Ub)=Ub;
        (*mpND_Vb)=Vb;
        (*mpND_Wb)=Wb;
        (*mpND_Pb)=Pb;
        (*mpND_Qb)=Qb;
        (*mpND_Rb)=Rb;
        (*mpND_q0)=q0;
        (*mpND_q1)=q1;
        (*mpND_q2)=q2;
        (*mpND_q3)=q3;
        (*mpND_AlphaAttack)=AlphaAttack;
        (*mpND_BetaSlip)=BetaSlip;
        (*mpND_altitude)=altitude;
        (*mpND_gfx)=gfx;
        (*mpND_gfy)=gfy;
        (*mpND_gfz)=gfz;
        (*mpND_CL1)=CL1;
        (*mpND_Cd1)=Cd1;
        (*mpND_Fax)=Fax;
        (*mpND_Faz)=Faz;

        //Update the delayed variabels
        mDelayedPart11.update(delayParts1[1]);
        mDelayedPart21.update(delayParts2[1]);
        mDelayedPart31.update(delayParts3[1]);
        mDelayedPart41.update(delayParts4[1]);
        mDelayedPart51.update(delayParts5[1]);
        mDelayedPart61.update(delayParts6[1]);
        mDelayedPart71.update(delayParts7[1]);
        mDelayedPart81.update(delayParts8[1]);
        mDelayedPart91.update(delayParts9[1]);
        mDelayedPart101.update(delayParts10[1]);
        mDelayedPart111.update(delayParts11[1]);
        mDelayedPart121.update(delayParts12[1]);
        mDelayedPart131.update(delayParts13[1]);

     }
};
#endif // AEROAIRCRAFT6DOF_HPP_INCLUDED
