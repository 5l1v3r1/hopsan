#ifndef AEROATMOSPHERE_HPP_INCLUDED
#define AEROATMOSPHERE_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file AeroAtmosphere.hpp
//! @author Petter Krus <petter.krus@liu.se>
//! @date Fri 24 Aug 2012 10:58:33
//! @brief model of standard atmosphere
//! @ingroup AeroComponents
//!
//This component is generated by COMPGEN for HOPSAN-NG simulation 
//from 
/*{, C:, Documents and Settings, petkr14, My Documents, \
CompgenNG}/atmosphereNG.nb*/

using namespace hopsan;

class AeroAtmosphere : public ComponentSignal
{
private:
     double mg0;
     double mrhos;
     double ma;
     double mR;
     double mgamma;
     double mTs;
     double mp0s;
     double mhtp;
     double mTtp;
     double mptp;
     double mrhotp;
     double me;
     double mha;
     Port *mpPha;
     Port *mpPrho;
     Port *mpPT;
     Port *mpPp0;
     Port *mpPVsound;
     int mNstep;
     //inputVariables
     double ha;
     //outputVariables
     double rho;
     double T;
     double p0;
     double Vsound;
     //Expressions variables
     //Delay declarations
     //inputVariables pointers
     double *mpND_ha;
     //outputVariables pointers
     double *mpND_rho;
     double *mpND_T;
     double *mpND_p0;
     double *mpND_Vsound;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new AeroAtmosphere();
     }

     void configure()
     {
        const double g0 = 9.81;
        const double rhos = 1.225;
        const double a = -0.0065;
        const double R = 287;
        const double gamma = 1.4;
        const double Ts = 288.16;
        const double p0s = 101300.;
        const double htp = 11000.;
        const double Ttp = 216.66;
        const double ptp = 22610.;
        const double rhotp = 0.363649;
        const double e = 2.71828;
        const double ha = 0.;

        mNstep=9;
        mg0 = g0;
        mrhos = rhos;
        ma = a;
        mR = R;
        mgamma = gamma;
        mTs = Ts;
        mp0s = p0s;
        mhtp = htp;
        mTtp = Ttp;
        mptp = ptp;
        mrhotp = rhotp;
        me = e;
        mha = ha;

        //Add ports to the component

        //Add inputVariables ports to the component
        mpPha=addReadPort("Pha","NodeSignal", Port::NotRequired);

        //Add outputVariables ports to the component
        mpPrho=addWritePort("Prho","NodeSignal", Port::NotRequired);
        mpPT=addWritePort("PT","NodeSignal", Port::NotRequired);
        mpPp0=addWritePort("Pp0","NodeSignal", Port::NotRequired);
        mpPVsound=addWritePort("PVsound","NodeSignal", Port::NotRequired);

        //Register changable parameters to the HOPSAN++ core
        registerParameter("g0", "Gravitation acceleration", "m/s^2", mg0);
        registerParameter("rhos", "Density at sea level", "kg/m3", mrhos);
        registerParameter("a", "", "", ma);
        registerParameter("R", "", "", mR);
        registerParameter("gamma", "", "", mgamma);
        registerParameter("Ts", "Temperature at sea level", "K", mTs);
        registerParameter("p0s", "", "Pa", mp0s);
        registerParameter("htp", "Onset of tropopaus", "m", mhtp);
        registerParameter("Ttp", "", "K", mTtp);
        registerParameter("ptp", "", "Pa", mptp);
        registerParameter("rhotp", "", "kg/m3", mrhotp);
        registerParameter("e", "e", "", me);
        registerParameter("ha", "Altitude", "m", mha);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Read inputVariables pointers from nodes
        mpND_ha=getSafeNodeDataPtr(mpPha, NodeSignal::VALUE,mha);
        //Read outputVariable pointers from nodes
        mpND_rho=getSafeNodeDataPtr(mpPrho, NodeSignal::VALUE);
        mpND_T=getSafeNodeDataPtr(mpPT, NodeSignal::VALUE);
        mpND_p0=getSafeNodeDataPtr(mpPp0, NodeSignal::VALUE);
        mpND_Vsound=getSafeNodeDataPtr(mpPVsound, NodeSignal::VALUE);

        //Read variables from nodes

        //Read inputVariables from nodes
        ha = (*mpND_ha);

        //Read outputVariables from nodes
        rho = mpPrho->getStartValue(NodeSignal::VALUE);
        T = mpPT->getStartValue(NodeSignal::VALUE);
        p0 = mpPp0->getStartValue(NodeSignal::VALUE);
        Vsound = mpPVsound->getStartValue(NodeSignal::VALUE);



        //Initialize delays

     }
    void simulateOneTimestep()
     {
        //Read variables from nodes

        //Read inputVariables from nodes
        ha = (*mpND_ha);

        //LocalExpressions

          //Expressions
          rho = (mrhotp*onPositive(ha - mhtp))/Power(me,(mg0*(ha - \
mhtp))/(mR*mTtp)) + mrhos*onNegative(ha - mhtp)*Power(((ha*ma + \
mTs)*onNegative(ha - mhtp) + (ma*mhtp + mTs)*onPositive(ha - mhtp))/mTs,-1 - \
mg0/(ma*mR));
          T = (ha*ma + mTs)*onNegative(ha - mhtp) + (ma*mhtp + \
mTs)*onPositive(ha - mhtp);
          p0 = (mptp*onPositive(ha - mhtp))/Power(me,(mg0*(ha - \
mhtp))/(mR*mTtp)) + (mp0s*onNegative(ha - mhtp))/Power(((ha*ma + \
mTs)*onNegative(ha - mhtp) + (ma*mhtp + mTs)*onPositive(ha - \
mhtp))/mTs,mg0/(ma*mR));
          Vsound = Sqrt(mgamma*mR*((ha*ma + mTs)*onNegative(ha - mhtp) + \
(ma*mhtp + mTs)*onPositive(ha - mhtp)));

        //Calculate the delayed parts


        //Write new values to nodes
        //outputVariables
        (*mpND_rho)=rho;
        (*mpND_T)=T;
        (*mpND_p0)=p0;
        (*mpND_Vsound)=Vsound;

        //Update the delayed variabels

     }
};
#endif // AEROATMOSPHERE_HPP_INCLUDED
