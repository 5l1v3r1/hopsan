#ifndef SIGNALATTITUDECONTROL_HPP_INCLUDED
#define SIGNALATTITUDECONTROL_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file \
C:\HopsanTrunk\HOPSAN++\ComponentLibraries\defaultLibrary\Special\AeroCompone\
nts\SignalAttitudeControl.hpp
//! @author Petter Krus <petter.krus@liu.se>
//! @date Mon 13 May 2013 18:46:46
//! @brief Attitude control unit for an aircraft
//! @ingroup SignalComponents
//!
//==This code has been autogenerated using Compgen==
//from 
/*{, C:, HopsanTrunk, HOPSAN++, CompgenModels}/SignalControlAero.nb*/

using namespace hopsan;

class SignalAttitudeControl : public ComponentSignal
{
private:
     double Kphi;
     double Kphipsi;
     double Kelev;
     double Kdelev;
     double Krud;
     double Kdrud;
     double u1min;
     double u1max;
     double u2min;
     double u2max;
     double u3min;
     double u3max;
     double U0;
     int mNstep;
//==This code has been autogenerated using Compgen==
     //inputVariables
     double phiref;
     double thetaref;
     double psiref;
     double phimax;
     double phi;
     double theta;
     double psi;
     double beta;
     double Qb;
     double Rb;
     double Ub;
     //outputVariables
     double uaerL;
     double uaerR;
     double uelev;
     double urud;
     //LocalExpressions variables
     double Kv;
     double u1cmin;
     double u1cmax;
     double u2cmin;
     double u2cmax;
     double u3cmin;
     double u3cmax;
     //Expressions variables
     //Delay declarations
//==This code has been autogenerated using Compgen==
     //inputVariables pointers
     double *mpphiref;
     double *mpthetaref;
     double *mppsiref;
     double *mpphimax;
     double *mpphi;
     double *mptheta;
     double *mppsi;
     double *mpbeta;
     double *mpQb;
     double *mpRb;
     double *mpUb;
     //outputVariables pointers
     double *mpuaerL;
     double *mpuaerR;
     double *mpuelev;
     double *mpurud;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new SignalAttitudeControl();
     }

     void configure()
     {
//==This code has been autogenerated using Compgen==

        mNstep=9;

        //Add ports to the component
        //Add inputVariables to the component
            addInputVariable("phiref","Reference signal \
roll","rad",0.,&mpphiref);
            addInputVariable("thetaref","Reference signal \
tip","rad",0.,&mpthetaref);
            addInputVariable("psiref","Reference signal \
yaw","rad",0.,&mppsiref);
            addInputVariable("phimax","Maximum bank angle for \
turn","rad",1.,&mpphimax);
            addInputVariable("phi","roll angle","rad",0.,&mpphi);
            addInputVariable("theta","tipp angle","rad",0.,&mptheta);
            addInputVariable("psi","yaw angle","rad",0.,&mppsi);
            addInputVariable("beta","side slip angle","rad",0.,&mpbeta);
            addInputVariable("Qb","tip angle rate","rad/s",0.,&mpQb);
            addInputVariable("Rb","yaw angle rate","rad/s",0.,&mpRb);
            addInputVariable("Ub","actual speed","m/s",0.,&mpUb);

        //Add outputVariables to the component
            addOutputVariable("uaerL","left aerleron","rad",0.,&mpuaerL);
            addOutputVariable("uaerR","right aerleron","rad",0.,&mpuaerR);
            addOutputVariable("uelev","elevator","rad",0.,&mpuelev);
            addOutputVariable("urud","rudder","rad",0.,&mpurud);

//==This code has been autogenerated using Compgen==
        //Add constants/parameters
            addConstant("Kphi", "Gain roll", "rad", 3.,Kphi);
            addConstant("Kphipsi", "Gain yaw/roll", "rad", 2.,Kphipsi);
            addConstant("Kelev", "Gain tip, default", "rad", 4.,Kelev);
            addConstant("Kdelev", "Gain tip, default", "rad", 1.,Kdelev);
            addConstant("Krud", "Gain yaw, default", "rad", 1.,Krud);
            addConstant("Kdrud", "Gain yaw rate, default", "", 1.,Kdrud);
            addConstant("u1min", "Minium output signal roll", "rad", \
-0.9,u1min);
            addConstant("u1max", "Maximum output signal roll", "rad", \
0.9,u1max);
            addConstant("u2min", "Minium output signal tip", "rad", \
-0.7,u2min);
            addConstant("u2max", "Maximum output signal tip", "rad", \
0.7,u2max);
            addConstant("u3min", "Minium output signal yaw", "rad", \
-0.7,u3min);
            addConstant("u3max", "Maximum output signal yaw", "rad", \
0.7,u3max);
            addConstant("U0", "Reference speed for compensation", "m/s", \
100.,U0);
     }

    void initialize()
     {
        //Read port variable pointers from nodes

        //Read variables from nodes

        //Read inputVariables from nodes
        phiref = (*mpphiref);
        thetaref = (*mpthetaref);
        psiref = (*mppsiref);
        phimax = (*mpphimax);
        phi = (*mpphi);
        theta = (*mptheta);
        psi = (*mppsi);
        beta = (*mpbeta);
        Qb = (*mpQb);
        Rb = (*mpRb);
        Ub = (*mpUb);

        //Read outputVariables from nodes
        uaerL = (*mpuaerL);
        uaerR = (*mpuaerR);
        uelev = (*mpuelev);
        urud = (*mpurud);

//==This code has been autogenerated using Compgen==

        //LocalExpressions
        Kv = Power(U0,2)/(Power(U0,2) + Power(Abs(Ub),2));
        u1cmin = Kv*u1min;
        u1cmax = Kv*u1max;
        u2cmin = Kv*u2min;
        u2cmax = Kv*u2max;
        u3cmin = u3min;
        u3cmax = u3max;

        //Initialize delays

     }
    void simulateOneTimestep()
     {
        //Read variables from nodes

        //Read inputVariables from nodes
        phiref = (*mpphiref);
        thetaref = (*mpthetaref);
        psiref = (*mppsiref);
        phimax = (*mpphimax);
        phi = (*mpphi);
        theta = (*mptheta);
        psi = (*mppsi);
        beta = (*mpbeta);
        Qb = (*mpQb);
        Rb = (*mpRb);
        Ub = (*mpUb);

        //LocalExpressions
        Kv = Power(U0,2)/(Power(U0,2) + Power(Abs(Ub),2));
        u1cmin = Kv*u1min;
        u1cmax = Kv*u1max;
        u2cmin = Kv*u2min;
        u2cmax = Kv*u2max;
        u3cmin = u3min;
        u3cmax = u3max;

          //Expressions
          uaerL = limit(Kphi*Kv*(diffAngle(phiref,phi) + \
limit(Kphipsi*diffAngle(psiref,psi),-phimax,phimax)),u1cmin,u1cmax);
          uaerR = limit(-(Kphi*Kv*(diffAngle(phiref,phi) + \
limit(Kphipsi*diffAngle(psiref,psi),-phimax,phimax))),u1cmin,u1cmax);
          uelev = limit(Kdelev*Kv*Qb - \
Kelev*Kv*diffAngle(thetaref,theta),u2cmin,u2cmax);
          urud = limit(-(beta*Krud) - Kdrud*Kv*Rb,u3cmin,u3cmax);

        //Calculate the delayed parts


        //Write new values to nodes
        //outputVariables
        (*mpuaerL)=uaerL;
        (*mpuaerR)=uaerR;
        (*mpuelev)=uelev;
        (*mpurud)=urud;

        //Update the delayed variabels

     }
    void deconfigure()
    {
        delete mpSolver;
    }
};
#endif // SIGNALATTITUDECONTROL_HPP_INCLUDED
