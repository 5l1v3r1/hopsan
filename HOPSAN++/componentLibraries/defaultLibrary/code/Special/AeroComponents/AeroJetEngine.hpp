#ifndef AEROJETENGINE_HPP_INCLUDED
#define AEROJETENGINE_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file AeroJetEngine.hpp
//! @author Petter Krus <petter.krus@liu.se>
//! @date Thu 23 Aug 2012 15:03:48
//! @brief Calulates the mass of remaining fuel in tank
//! @ingroup AeroComponents
//!
//This component is generated by COMPGEN for HOPSAN-NG simulation 
//from 
/*{, C:, Documents and Settings, petkr14, My Documents, \
CompgenNG}/AeroComponentsNG.nb*/

using namespace hopsan;

class AeroJetEngine : public ComponentQ
{
private:
     double mthrustmax;
     double mSFC;
     double mBR;
     double mthau;
     double mCspeed;
     double muin;
     double mrho;
     double mT;
     double mp0;
     double mVsound;
     double mspeed;
     Port *mpPuin;
     Port *mpPrho;
     Port *mpPT;
     Port *mpPp0;
     Port *mpPVsound;
     Port *mpPspeed;
     Port *mpPthrust;
     Port *mpPmfuel;
     Port *mpPShspeed;
     Port *mpPqmfuel;
     double delayParts1[9];
     double delayParts2[9];
     double delayParts3[9];
     Matrix jacobianMatrix;
     Vec systemEquations;
     Matrix delayedPart;
     int i;
     int iter;
     int mNoiter;
     double jsyseqnweight[4];
     int order[2];
     int mNstep;
     //inputVariables
     double uin;
     double rho;
     double T;
     double p0;
     double Vsound;
     double speed;
     //outputVariables
     double thrust;
     double mfuel;
     double Shspeed;
     double qmfuel;
     //Expressions variables
     //Delay declarations
     //inputVariables pointers
     double *mpND_uin;
     double *mpND_rho;
     double *mpND_T;
     double *mpND_p0;
     double *mpND_Vsound;
     double *mpND_speed;
     //outputVariables pointers
     double *mpND_thrust;
     double *mpND_mfuel;
     double *mpND_Shspeed;
     double *mpND_qmfuel;
     Delay mDelayedPart10;
     Delay mDelayedPart11;
     Delay mDelayedPart20;
     Delay mDelayedPart21;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new AeroJetEngine();
     }

     void configure()
     {
        const double thrustmax = 5000.;
        const double SFC = 0.0000171;
        const double BR = 2;
        const double thau = 5.;
        const double Cspeed = 1.;
        const double uin = 1.;
        const double rho = 1.25;
        const double T = 273.;
        const double p0 = 100000.;
        const double Vsound = 340.;
        const double speed = 100.;

        mNstep=9;
        jacobianMatrix.create(2,2);
        systemEquations.create(2);
        delayedPart.create(3,6);
        mNoiter=2;
        jsyseqnweight[0]=1;
        jsyseqnweight[1]=0.67;
        jsyseqnweight[2]=0.5;
        jsyseqnweight[3]=0.5;

        mthrustmax = thrustmax;
        mSFC = SFC;
        mBR = BR;
        mthau = thau;
        mCspeed = Cspeed;
        muin = uin;
        mrho = rho;
        mT = T;
        mp0 = p0;
        mVsound = Vsound;
        mspeed = speed;

        //Add ports to the component

        //Add inputVariables ports to the component
        mpPuin=addReadPort("Puin","NodeSignal", Port::NOTREQUIRED);
        mpPrho=addReadPort("Prho","NodeSignal", Port::NOTREQUIRED);
        mpPT=addReadPort("PT","NodeSignal", Port::NOTREQUIRED);
        mpPp0=addReadPort("Pp0","NodeSignal", Port::NOTREQUIRED);
        mpPVsound=addReadPort("PVsound","NodeSignal", Port::NOTREQUIRED);
        mpPspeed=addReadPort("Pspeed","NodeSignal", Port::NOTREQUIRED);

        //Add outputVariables ports to the component
        mpPthrust=addWritePort("Pthrust","NodeSignal", Port::NOTREQUIRED);
        mpPmfuel=addWritePort("Pmfuel","NodeSignal", Port::NOTREQUIRED);
        mpPShspeed=addWritePort("PShspeed","NodeSignal", Port::NOTREQUIRED);
        mpPqmfuel=addWritePort("Pqmfuel","NodeSignal", Port::NOTREQUIRED);

        //Register changable parameters to the HOPSAN++ core
        registerParameter("thrustmax", "Max thrust", "N", mthrustmax);
        registerParameter("SFC", "Nominal thrust specific fuel consumption", \
"kg/(N s)", mSFC);
        registerParameter("BR", "Bypass ratio", "", mBR);
        registerParameter("thau", "Engine time constant", "s", mthau);
        registerParameter("Cspeed", "thrust-speed coefficient", "", mCspeed);
        registerParameter("uin", "Throttle setting 0-1", "", muin);
        registerParameter("rho", "The density at altitude h", "kg/m3", mrho);
        registerParameter("T", "Temperature at altitude h", "K", mT);
        registerParameter("p0", "Pressure at altitude h", "Pa", mp0);
        registerParameter("Vsound", "Speed of sound at altitude h", "m/s", \
mVsound);
        registerParameter("speed", "Air speed", "m/s", mspeed);
        mpSolver = new EquationSystemSolver(this,2);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Read inputVariables pointers from nodes
        mpND_uin=getSafeNodeDataPtr(mpPuin, NodeSignal::VALUE,muin);
        mpND_rho=getSafeNodeDataPtr(mpPrho, NodeSignal::VALUE,mrho);
        mpND_T=getSafeNodeDataPtr(mpPT, NodeSignal::VALUE,mT);
        mpND_p0=getSafeNodeDataPtr(mpPp0, NodeSignal::VALUE,mp0);
        mpND_Vsound=getSafeNodeDataPtr(mpPVsound, NodeSignal::VALUE,mVsound);
        mpND_speed=getSafeNodeDataPtr(mpPspeed, NodeSignal::VALUE,mspeed);
        //Read outputVariable pointers from nodes
        mpND_thrust=getSafeNodeDataPtr(mpPthrust, NodeSignal::VALUE);
        mpND_mfuel=getSafeNodeDataPtr(mpPmfuel, NodeSignal::VALUE);
        mpND_Shspeed=getSafeNodeDataPtr(mpPShspeed, NodeSignal::VALUE);
        mpND_qmfuel=getSafeNodeDataPtr(mpPqmfuel, NodeSignal::VALUE);

        //Read variables from nodes

        //Read inputVariables from nodes
        uin = (*mpND_uin);
        rho = (*mpND_rho);
        T = (*mpND_T);
        p0 = (*mpND_p0);
        Vsound = (*mpND_Vsound);
        speed = (*mpND_speed);

        //Read outputVariables from nodes
        thrust = mpPthrust->getStartValue(NodeSignal::VALUE);
        mfuel = mpPmfuel->getStartValue(NodeSignal::VALUE);
        Shspeed = mpPShspeed->getStartValue(NodeSignal::VALUE);
        qmfuel = mpPqmfuel->getStartValue(NodeSignal::VALUE);



        //Initialize delays
        delayParts1[1] = (-2.*mthau*thrust + mTimestep*thrust - \
0.8*mthrustmax*mTimestep*rho*uin)/(2.*mthau + mTimestep);
        mDelayedPart11.initialize(mNstep,delayParts1[1]);
        delayParts2[1] = (-2*mfuel - mSFC*mTimestep*thrust)/2.;
        mDelayedPart21.initialize(mNstep,delayParts2[1]);

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
     }
    void simulateOneTimestep()
     {
        Vec stateVar(2);
        Vec stateVark(2);
        Vec deltaStateVar(2);

        //Read variables from nodes

        //Read inputVariables from nodes
        uin = (*mpND_uin);
        rho = (*mpND_rho);
        T = (*mpND_T);
        p0 = (*mpND_p0);
        Vsound = (*mpND_Vsound);
        speed = (*mpND_speed);

        //LocalExpressions

        //Initializing variable vector for Newton-Raphson
        stateVark[0] = thrust;
        stateVark[1] = mfuel;

        //Iterative solution using Newton-Rapshson
        for(iter=1;iter<=mNoiter;iter++)
        {
         //JetEngine
         //Differential-algebraic system of equation parts

          //Assemble differential-algebraic equations
          systemEquations[0] =thrust - \
(0.8*mthrustmax*mTimestep*rho*uin)/(2.*mthau + mTimestep) + \
delayedPart[1][1];
          systemEquations[1] =mfuel - (mSFC*mTimestep*thrust)/2. + \
delayedPart[2][1];

          //Jacobian matrix
          jacobianMatrix[0][0] = 1;
          jacobianMatrix[0][1] = 0;
          jacobianMatrix[1][0] = -(mSFC*mTimestep)/2.;
          jacobianMatrix[1][1] = 1;

          //Solving equation using LU-faktorisation
          mpSolver->solve(jacobianMatrix, systemEquations, stateVark, iter);
          thrust=stateVark[0];
          mfuel=stateVark[1];
          //Expressions
          Shspeed = mCspeed*thrust;
          qmfuel = mSFC*thrust;
        }

        //Calculate the delayed parts
        delayParts1[1] = (-2.*mthau*thrust + mTimestep*thrust - \
0.8*mthrustmax*mTimestep*rho*uin)/(2.*mthau + mTimestep);
        delayParts2[1] = (-2*mfuel - mSFC*mTimestep*thrust)/2.;

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];

        //Write new values to nodes
        //outputVariables
        (*mpND_thrust)=thrust;
        (*mpND_mfuel)=mfuel;
        (*mpND_Shspeed)=Shspeed;
        (*mpND_qmfuel)=qmfuel;

        //Update the delayed variabels
        mDelayedPart11.update(delayParts1[1]);
        mDelayedPart21.update(delayParts2[1]);

     }
};
#endif // AEROJETENGINE_HPP_INCLUDED
