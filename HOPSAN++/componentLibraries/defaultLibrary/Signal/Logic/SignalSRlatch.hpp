#ifndef SIGNALSRLATCH_HPP_INCLUDED
#define SIGNALSRLATCH_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file SignalSRlatch.hpp
//! @author Petter Krus <petter.krus@liu.se>
//! @date Fri 24 Aug 2012 10:28:19
//! @brief S-R latch
//! @ingroup SignalComponents
//!
//This component is generated by COMPGEN for HOPSAN-NG simulation 
//from 
/*{, C:, Documents and Settings, petkr14, My Documents, \
CompgenNG}/FFBDcomponentsNG.nb*/

using namespace hopsan;

class SignalSRlatch : public ComponentSignal
{
private:
     double msetCond;
     double mresetCond;
     Port *mpPsetCond;
     Port *mpPresetCond;
     Port *mpPQstate;
     Port *mpPnotQstate;
     int mNstep;
     //inputVariables
     double setCond;
     double resetCond;
     //outputVariables
     double Qstate;
     double notQstate;
     //Expressions variables
     double oldQstate;
     //Delay declarations
     //inputVariables pointers
     double *mpND_setCond;
     double *mpND_resetCond;
     //outputVariables pointers
     double *mpND_Qstate;
     double *mpND_notQstate;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new SignalSRlatch();
     }

     void configure()
     {
        const double setCond = 0.;
        const double resetCond = 0.;

        mNstep=9;
        msetCond = setCond;
        mresetCond = resetCond;

        //Add ports to the component

        //Add inputVariables ports to the component
        mpPsetCond=addReadPort("PsetCond","NodeSignal", Port::NotRequired);
        mpPresetCond=addReadPort("PresetCond","NodeSignal", \
Port::NotRequired);

        //Add outputVariables ports to the component
        mpPQstate=addWritePort("PQstate","NodeSignal", Port::NotRequired);
        mpPnotQstate=addWritePort("PnotQstate","NodeSignal", \
Port::NotRequired);

        //Register changable parameters to the HOPSAN++ core
        registerParameter("setCond", "On condition", "", msetCond);
        registerParameter("resetCond", "off condition", "", mresetCond);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Read inputVariables pointers from nodes
        mpND_setCond=getSafeNodeDataPtr(mpPsetCond, \
NodeSignal::VALUE,msetCond);
        mpND_resetCond=getSafeNodeDataPtr(mpPresetCond, \
NodeSignal::VALUE,mresetCond);
        //Read outputVariable pointers from nodes
        mpND_Qstate=getSafeNodeDataPtr(mpPQstate, NodeSignal::VALUE);
        mpND_notQstate=getSafeNodeDataPtr(mpPnotQstate, NodeSignal::VALUE);

        //Read variables from nodes

        //Read inputVariables from nodes
        setCond = (*mpND_setCond);
        resetCond = (*mpND_resetCond);

        //Read outputVariables from nodes
        Qstate = mpPQstate->getStartValue(NodeSignal::VALUE);
        notQstate = mpPnotQstate->getStartValue(NodeSignal::VALUE);

        //InitialExpressions
        oldQstate = Qstate;


        //Initialize delays

     }
    void simulateOneTimestep()
     {
        //Read variables from nodes

        //Read inputVariables from nodes
        setCond = (*mpND_setCond);
        resetCond = (*mpND_resetCond);

        //LocalExpressions

          //Expressions
          Qstate = -0.5 + onPositive(-0.5 + oldQstate) - onPositive(-0.5 + \
resetCond) + onPositive(-0.5 + setCond);
          oldQstate = Qstate;
          notQstate = 1 - Qstate;

        //Calculate the delayed parts


        //Write new values to nodes
        //outputVariables
        (*mpND_Qstate)=Qstate;
        (*mpND_notQstate)=notQstate;

        //Update the delayed variabels

     }
};
#endif // SIGNALSRLATCH_HPP_INCLUDED
