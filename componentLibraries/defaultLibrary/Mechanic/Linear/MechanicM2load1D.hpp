#ifndef MECHANICM2LOAD1D_HPP_INCLUDED
#define MECHANICM2LOAD1D_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file MechanicM2load1D.hpp
//! @author Petter Krus <petter.krus@liu.se>
//! @date Thu 12 Feb 2015 02:03:58
//! @brief An inertia load with spring and damper
//! @ingroup MechanicComponents
//!
//==This code has been autogenerated using Compgen==
//from 
/*{, C:, HopsanTrunk, componentLibraries, defaultLibrary, Mechanic, \
Linear}/MechanicM2load1D.nb*/

using namespace hopsan;

class MechanicM2load1D : public ComponentQ
{
private:
     double m1;
     double m2;
     double bL;
     double xpmin;
     double xpmax;
     Port *mpPm1;
     Port *mpPm2;
     Port *mpPm3;
     double delayParts1[9];
     double delayParts2[9];
     double delayParts3[9];
     double delayParts4[9];
     double delayParts5[9];
     double delayParts6[9];
     double delayParts7[9];
     Matrix jacobianMatrix;
     Vec systemEquations;
     Matrix delayedPart;
     int i;
     int iter;
     int mNoiter;
     double jsyseqnweight[4];
     int order[7];
     int mNstep;
     //Port Pm1 variable
     double fm1;
     double xm1;
     double vm1;
     double cm1;
     double Zcm1;
     double eqMassm1;
     //Port Pm2 variable
     double fm2;
     double xm2;
     double vm2;
     double cm2;
     double Zcm2;
     double eqMassm2;
     //Port Pm3 variable
     double fm3;
     double xm3;
     double vm3;
     double cm3;
     double Zcm3;
     double eqMassm3;
//==This code has been autogenerated using Compgen==
     //inputVariables
     //outputVariables
     double vt;
     double xt;
     double vp;
     double xp;
     //InitialExpressions variables
     //Expressions variables
     //Port Pm1 pointer
     double *mpND_fm1;
     double *mpND_xm1;
     double *mpND_vm1;
     double *mpND_cm1;
     double *mpND_Zcm1;
     double *mpND_eqMassm1;
     //Port Pm2 pointer
     double *mpND_fm2;
     double *mpND_xm2;
     double *mpND_vm2;
     double *mpND_cm2;
     double *mpND_Zcm2;
     double *mpND_eqMassm2;
     //Port Pm3 pointer
     double *mpND_fm3;
     double *mpND_xm3;
     double *mpND_vm3;
     double *mpND_cm3;
     double *mpND_Zcm3;
     double *mpND_eqMassm3;
     //Delay declarations
//==This code has been autogenerated using Compgen==
     //inputVariables pointers
     //inputParameters pointers
     double *mpm1;
     double *mpm2;
     double *mpbL;
     double *mpxpmin;
     double *mpxpmax;
     //outputVariables pointers
     double *mpvt;
     double *mpxt;
     double *mpvp;
     double *mpxp;
     Delay mDelayedPart10;
     Delay mDelayedPart11;
     Delay mDelayedPart20;
     Delay mDelayedPart21;
     Delay mDelayedPart22;
     Delay mDelayedPart30;
     Delay mDelayedPart31;
     Delay mDelayedPart40;
     Delay mDelayedPart41;
     EquationSystemSolver *mpSolver;

public:
     static Component *Creator()
     {
        return new MechanicM2load1D();
     }

     void configure()
     {
//==This code has been autogenerated using Compgen==

        mNstep=9;
        jacobianMatrix.create(7,7);
        systemEquations.create(7);
        delayedPart.create(8,6);
        mNoiter=2;
        jsyseqnweight[0]=1;
        jsyseqnweight[1]=0.67;
        jsyseqnweight[2]=0.5;
        jsyseqnweight[3]=0.5;


        //Add ports to the component
        mpPm1=addPowerPort("Pm1","NodeMechanic");
        mpPm2=addPowerPort("Pm2","NodeMechanic");
        mpPm3=addPowerPort("Pm3","NodeMechanic");
        //Add inputVariables to the component

        //Add inputParammeters to the component
            addInputVariable("m1", "Inertia1", "kg", 1000.,&mpm1);
            addInputVariable("m2", "Inertia2", "kg", 1000.,&mpm2);
            addInputVariable("bL", "Visc. friction coeff.", "Ns/m", \
10.,&mpbL);
            addInputVariable("xpmin", "Limitation on stroke xp (-xm3)", "m", \
0.,&mpxpmin);
            addInputVariable("xpmax", "Limitation on stroke xp (-xm3)", "m", \
1.,&mpxpmax);
        //Add outputVariables to the component
            addOutputVariable("vt","cg speed","m/s",0.,&mpvt);
            addOutputVariable("xt","cg position","m",0.,&mpxt);
            addOutputVariable("vp","diff speed","m/s",0.,&mpvp);
            addOutputVariable("xp","diff position","m",0.,&mpxp);

//==This code has been autogenerated using Compgen==
        //Add constantParameters
        mpSolver = new EquationSystemSolver(this,7);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Port Pm1
        mpND_fm1=getSafeNodeDataPtr(mpPm1, NodeMechanic::Force);
        mpND_xm1=getSafeNodeDataPtr(mpPm1, NodeMechanic::Position);
        mpND_vm1=getSafeNodeDataPtr(mpPm1, NodeMechanic::Velocity);
        mpND_cm1=getSafeNodeDataPtr(mpPm1, NodeMechanic::WaveVariable);
        mpND_Zcm1=getSafeNodeDataPtr(mpPm1, NodeMechanic::CharImpedance);
        mpND_eqMassm1=getSafeNodeDataPtr(mpPm1, \
NodeMechanic::EquivalentMass);
        //Port Pm2
        mpND_fm2=getSafeNodeDataPtr(mpPm2, NodeMechanic::Force);
        mpND_xm2=getSafeNodeDataPtr(mpPm2, NodeMechanic::Position);
        mpND_vm2=getSafeNodeDataPtr(mpPm2, NodeMechanic::Velocity);
        mpND_cm2=getSafeNodeDataPtr(mpPm2, NodeMechanic::WaveVariable);
        mpND_Zcm2=getSafeNodeDataPtr(mpPm2, NodeMechanic::CharImpedance);
        mpND_eqMassm2=getSafeNodeDataPtr(mpPm2, \
NodeMechanic::EquivalentMass);
        //Port Pm3
        mpND_fm3=getSafeNodeDataPtr(mpPm3, NodeMechanic::Force);
        mpND_xm3=getSafeNodeDataPtr(mpPm3, NodeMechanic::Position);
        mpND_vm3=getSafeNodeDataPtr(mpPm3, NodeMechanic::Velocity);
        mpND_cm3=getSafeNodeDataPtr(mpPm3, NodeMechanic::WaveVariable);
        mpND_Zcm3=getSafeNodeDataPtr(mpPm3, NodeMechanic::CharImpedance);
        mpND_eqMassm3=getSafeNodeDataPtr(mpPm3, \
NodeMechanic::EquivalentMass);

        //Read variables from nodes
        //Port Pm1
        fm1 = (*mpND_fm1);
        xm1 = (*mpND_xm1);
        vm1 = (*mpND_vm1);
        cm1 = (*mpND_cm1);
        Zcm1 = (*mpND_Zcm1);
        eqMassm1 = (*mpND_eqMassm1);
        //Port Pm2
        fm2 = (*mpND_fm2);
        xm2 = (*mpND_xm2);
        vm2 = (*mpND_vm2);
        cm2 = (*mpND_cm2);
        Zcm2 = (*mpND_Zcm2);
        eqMassm2 = (*mpND_eqMassm2);
        //Port Pm3
        fm3 = (*mpND_fm3);
        xm3 = (*mpND_xm3);
        vm3 = (*mpND_vm3);
        cm3 = (*mpND_cm3);
        Zcm3 = (*mpND_Zcm3);
        eqMassm3 = (*mpND_eqMassm3);

        //Read inputVariables from nodes

        //Read inputParameters from nodes
        m1 = (*mpm1);
        m2 = (*mpm2);
        bL = (*mpbL);
        xpmin = (*mpxpmin);
        xpmax = (*mpxpmax);

        //Read outputVariables from nodes
        vt = (*mpvt);
        xt = (*mpxt);
        vp = (*mpvp);
        xp = (*mpxp);

//==This code has been autogenerated using Compgen==
        //InitialExpressions
        xm1 = -xm2;


        //Initialize delays
        delayParts1[1] = (-(fm2*m1*mTimestep) + fm3*m1*mTimestep - \
fm1*m2*mTimestep + fm3*m2*mTimestep - 2*m1*m2*vm3)/(2.*m1*m2);
        mDelayedPart11.initialize(mNstep,delayParts1[1]);
        delayParts2[1] = (-2*fm2*m1*Power(mTimestep,2) + \
2*fm3*m1*Power(mTimestep,2) - 2*fm1*m2*Power(mTimestep,2) + \
2*fm3*m2*Power(mTimestep,2) - 8*m1*m2*xm3)/(4.*m1*m2);
        mDelayedPart21.initialize(mNstep,delayParts2[1]);
        delayParts2[2] = (-(fm2*m1*Power(mTimestep,2)) + \
fm3*m1*Power(mTimestep,2) - fm1*m2*Power(mTimestep,2) + \
fm3*m2*Power(mTimestep,2) + 4*m1*m2*xm3)/(4.*m1*m2);
        mDelayedPart22.initialize(mNstep,delayParts2[2]);
        delayParts3[1] = (-(fm1*mTimestep) + fm2*mTimestep - 2*m1*vt - \
2*m2*vt)/(2*m1 + 2*m2);
        mDelayedPart31.initialize(mNstep,delayParts3[1]);
        delayParts4[1] = (-(mTimestep*vt) - 2*xt)/2.;
        mDelayedPart41.initialize(mNstep,delayParts4[1]);

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[2][2] = mDelayedPart22.getIdx(1);
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];
        delayedPart[6][1] = delayParts6[1];
        delayedPart[7][1] = delayParts7[1];
     }
    void simulateOneTimestep()
     {
        Vec stateVar(7);
        Vec stateVark(7);
        Vec deltaStateVar(7);

        //Read variables from nodes
        //Port Pm1
        cm1 = (*mpND_cm1);
        Zcm1 = (*mpND_Zcm1);
        //Port Pm2
        cm2 = (*mpND_cm2);
        Zcm2 = (*mpND_Zcm2);
        //Port Pm3
        cm3 = (*mpND_cm3);
        Zcm3 = (*mpND_Zcm3);

        //Read inputVariables from nodes

        //LocalExpressions

        //Initializing variable vector for Newton-Raphson
        stateVark[0] = vm3;
        stateVark[1] = xm3;
        stateVark[2] = vt;
        stateVark[3] = xt;
        stateVark[4] = fm1;
        stateVark[5] = fm2;
        stateVark[6] = fm3;

        //Iterative solution using Newton-Rapshson
        for(iter=1;iter<=mNoiter;iter++)
        {
         //M2load1D
         //Differential-algebraic system of equation parts

          //Assemble differential-algebraic equations
          systemEquations[0] =vm3 - dxLimit(limit(((fm2*m1 + fm1*m2 - fm3*(m1 \
+ m2))*Power(mTimestep,2))/(4.*m1*m2) - delayedPart[2][1] - \
delayedPart[2][2],-xpmax,-xpmin),-xpmax,-xpmin)*(((fm2*m1 + fm1*m2 - fm3*(m1 \
+ m2))*mTimestep)/(2.*m1*m2) - delayedPart[1][1]);
          systemEquations[1] =xm3 - limit(((fm2*m1 + fm1*m2 - fm3*(m1 + \
m2))*Power(mTimestep,2))/(4.*m1*m2) - delayedPart[2][1] - \
delayedPart[2][2],-xpmax,-xpmin);
          systemEquations[2] =((-fm1 + fm2)*mTimestep)/(2.*(m1 + m2)) + vt + \
delayedPart[3][1];
          systemEquations[3] =-(mTimestep*vt)/2. + xt + delayedPart[4][1];
          systemEquations[4] =-cm1 + fm1 + vm2*Zcm1;
          systemEquations[5] =-cm2 + fm2 - vm2*Zcm2;
          systemEquations[6] =-cm3 + fm3 - vm3*Zcm3;

          //Jacobian matrix
          jacobianMatrix[0][0] = 1;
          jacobianMatrix[0][1] = 0;
          jacobianMatrix[0][2] = 0;
          jacobianMatrix[0][3] = 0;
          jacobianMatrix[0][4] = -(mTimestep*dxLimit(limit(((fm2*m1 + fm1*m2 \
- fm3*(m1 + m2))*Power(mTimestep,2))/(4.*m1*m2) - delayedPart[2][1] - \
delayedPart[2][2],-xpmax,-xpmin),-xpmax,-xpmin))/(2.*m1);
          jacobianMatrix[0][5] = -(mTimestep*dxLimit(limit(((fm2*m1 + fm1*m2 \
- fm3*(m1 + m2))*Power(mTimestep,2))/(4.*m1*m2) - delayedPart[2][1] - \
delayedPart[2][2],-xpmax,-xpmin),-xpmax,-xpmin))/(2.*m2);
          jacobianMatrix[0][6] = -((-m1 - \
m2)*mTimestep*dxLimit(limit(((fm2*m1 + fm1*m2 - fm3*(m1 + \
m2))*Power(mTimestep,2))/(4.*m1*m2) - delayedPart[2][1] - \
delayedPart[2][2],-xpmax,-xpmin),-xpmax,-xpmin))/(2.*m1*m2);
          jacobianMatrix[1][0] = 0;
          jacobianMatrix[1][1] = 1;
          jacobianMatrix[1][2] = 0;
          jacobianMatrix[1][3] = 0;
          jacobianMatrix[1][4] = -(Power(mTimestep,2)*dxLimit(((fm2*m1 + \
fm1*m2 - fm3*(m1 + m2))*Power(mTimestep,2))/(4.*m1*m2) - delayedPart[2][1] - \
delayedPart[2][2],-xpmax,-xpmin))/(4.*m1);
          jacobianMatrix[1][5] = -(Power(mTimestep,2)*dxLimit(((fm2*m1 + \
fm1*m2 - fm3*(m1 + m2))*Power(mTimestep,2))/(4.*m1*m2) - delayedPart[2][1] - \
delayedPart[2][2],-xpmax,-xpmin))/(4.*m2);
          jacobianMatrix[1][6] = -((-m1 - \
m2)*Power(mTimestep,2)*dxLimit(((fm2*m1 + fm1*m2 - fm3*(m1 + \
m2))*Power(mTimestep,2))/(4.*m1*m2) - delayedPart[2][1] - \
delayedPart[2][2],-xpmax,-xpmin))/(4.*m1*m2);
          jacobianMatrix[2][0] = 0;
          jacobianMatrix[2][1] = 0;
          jacobianMatrix[2][2] = 1;
          jacobianMatrix[2][3] = 0;
          jacobianMatrix[2][4] = -mTimestep/(2.*(m1 + m2));
          jacobianMatrix[2][5] = mTimestep/(2.*(m1 + m2));
          jacobianMatrix[2][6] = 0;
          jacobianMatrix[3][0] = 0;
          jacobianMatrix[3][1] = 0;
          jacobianMatrix[3][2] = -mTimestep/2.;
          jacobianMatrix[3][3] = 1;
          jacobianMatrix[3][4] = 0;
          jacobianMatrix[3][5] = 0;
          jacobianMatrix[3][6] = 0;
          jacobianMatrix[4][0] = 0;
          jacobianMatrix[4][1] = 0;
          jacobianMatrix[4][2] = 0;
          jacobianMatrix[4][3] = 0;
          jacobianMatrix[4][4] = 1;
          jacobianMatrix[4][5] = 0;
          jacobianMatrix[4][6] = 0;
          jacobianMatrix[5][0] = 0;
          jacobianMatrix[5][1] = 0;
          jacobianMatrix[5][2] = 0;
          jacobianMatrix[5][3] = 0;
          jacobianMatrix[5][4] = 0;
          jacobianMatrix[5][5] = 1;
          jacobianMatrix[5][6] = 0;
          jacobianMatrix[6][0] = -Zcm3;
          jacobianMatrix[6][1] = 0;
          jacobianMatrix[6][2] = 0;
          jacobianMatrix[6][3] = 0;
          jacobianMatrix[6][4] = 0;
          jacobianMatrix[6][5] = 0;
          jacobianMatrix[6][6] = 1;
//==This code has been autogenerated using Compgen==

          //Solving equation using LU-faktorisation
          mpSolver->solve(jacobianMatrix, systemEquations, stateVark, iter);
          vm3=stateVark[0];
          xm3=stateVark[1];
          vt=stateVark[2];
          xt=stateVark[3];
          fm1=stateVark[4];
          fm2=stateVark[5];
          fm3=stateVark[6];
          //Expressions
          vm1 = -((m2*vm3 + (m1 + m2)*vt)/(m1 + m2));
          vm2 = -((m1*vm3 - (m1 + m2)*vt)/(m1 + m2));
          xm1 = -((m2*xm3 + (m1 + m2)*xt)/(m1 + m2));
          xm2 = -((m1*xm3 - (m1 + m2)*xt)/(m1 + m2));
          vp = -vm3;
          xp = -xm3;
          eqMassm1 = m1;
          eqMassm2 = m2;
        }

        //Calculate the delayed parts
        delayParts1[1] = (-(fm2*m1*mTimestep) + fm3*m1*mTimestep - \
fm1*m2*mTimestep + fm3*m2*mTimestep - 2*m1*m2*vm3)/(2.*m1*m2);
        delayParts2[1] = (-2*fm2*m1*Power(mTimestep,2) + \
2*fm3*m1*Power(mTimestep,2) - 2*fm1*m2*Power(mTimestep,2) + \
2*fm3*m2*Power(mTimestep,2) - 8*m1*m2*xm3)/(4.*m1*m2);
        delayParts2[2] = (-(fm2*m1*Power(mTimestep,2)) + \
fm3*m1*Power(mTimestep,2) - fm1*m2*Power(mTimestep,2) + \
fm3*m2*Power(mTimestep,2) + 4*m1*m2*xm3)/(4.*m1*m2);
        delayParts3[1] = (-(fm1*mTimestep) + fm2*mTimestep - 2*m1*vt - \
2*m2*vt)/(2*m1 + 2*m2);
        delayParts4[1] = (-(mTimestep*vt) - 2*xt)/2.;

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[2][2] = mDelayedPart22.getIdx(0);
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];
        delayedPart[6][1] = delayParts6[1];
        delayedPart[7][1] = delayParts7[1];

        //Write new values to nodes
        //Port Pm1
        (*mpND_fm1)=fm1;
        (*mpND_xm1)=xm1;
        (*mpND_vm1)=vm1;
        (*mpND_eqMassm1)=eqMassm1;
        //Port Pm2
        (*mpND_fm2)=fm2;
        (*mpND_xm2)=xm2;
        (*mpND_vm2)=vm2;
        (*mpND_eqMassm2)=eqMassm2;
        //Port Pm3
        (*mpND_fm3)=fm3;
        (*mpND_xm3)=xm3;
        (*mpND_vm3)=vm3;
        (*mpND_eqMassm3)=eqMassm3;
        //outputVariables
        (*mpvt)=vt;
        (*mpxt)=xt;
        (*mpvp)=vp;
        (*mpxp)=xp;

        //Update the delayed variabels
        mDelayedPart11.update(delayParts1[1]);
        mDelayedPart21.update(delayParts2[1]);
        mDelayedPart22.update(delayParts2[2]);
        mDelayedPart31.update(delayParts3[1]);
        mDelayedPart41.update(delayParts4[1]);

     }
    void deconfigure()
    {
        delete mpSolver;
    }
};
#endif // MECHANICM2LOAD1D_HPP_INCLUDED
